<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> Hexo </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/06/2-Java内存区域与内存溢出异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/06/2-Java内存区域与内存溢出异常/" itemprop="url">
                  2. Java内存区域与内存溢出异常
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-06T17:41:20+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1　概述"></a>2.1　概述</h2><p>&emsp;&emsp;对于从事C、C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的“皇帝”又是从事最基础工作的“劳动人民”——既拥有每一个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。</p>
<p>&emsp;&emsp;对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。</p>
<p>&emsp;&emsp;本章是第二部分的第1章，笔者将从概念上介绍Java虚拟机内存的各个区域，讲解这些区域的作用、服务对象以及其中可能产生的问题，这是翻越虚拟机内存管理这堵围墙的第一步。</p>
<h2 id="2-2-运行时数据区域"><a href="#2-2-运行时数据区域" class="headerlink" title="2.2　运行时数据区域"></a>2.2　运行时数据区域</h2><p>&emsp;&emsp;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如图2-1所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201703/30183148_xkqk.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h3 id="2-2-1-程序计数器"><a href="#2-2-1-程序计数器" class="headerlink" title="2.2.1　程序计数器"></a>2.2.1　程序计数器</h3><p>&emsp;&emsp;程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是 <strong>当前线程所执行的字节码的行号指示器</strong> 。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>&emsp;&emsp;由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p>
<p>&emsp;&emsp;如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p>
<h3 id="2-2-2-Java虚拟机栈"><a href="#2-2-2-Java虚拟机栈" class="headerlink" title="2.2.2　Java虚拟机栈"></a>2.2.2　Java虚拟机栈</h3><p>&emsp;&emsp;与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。（延伸阅读：<a href="http://denverj.iteye.com/blog/1218236" target="_blank" rel="external">栈帧</a>、<a href="http://denverj.iteye.com/blog/1218359" target="_blank" rel="external">操作数栈</a>，<a href="http://denverj.iteye.com/blog/1218298" target="_blank" rel="external">局部变量表</a>）</p>
<p>&emsp;&emsp;经常有人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行只能说明大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。其中所指的“堆”笔者在后面会专门讲述，而所指的“栈”就是现在讲的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</p>
<p>&emsp;&emsp;局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>&emsp;&emsp;其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>
<p>&emsp;&emsp;在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p>
<h3 id="2-2-3-本地方法栈"><a href="#2-2-3-本地方法栈" class="headerlink" title="2.2.3　本地方法栈"></a>2.2.3　本地方法栈</h3><p>&emsp;&emsp;本地方法栈（Native Method Stack）与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常。</p>
<h3 id="2-2-4-Java堆"><a href="#2-2-4-Java堆" class="headerlink" title="2.2.4　Java堆"></a>2.2.4　Java堆</h3><p>&emsp;&emsp;对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配[1]，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换[2]优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。</p>
<p>&emsp;&emsp;Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC堆”（Garbage Collected Heap，幸好国内没翻译成“垃圾堆”）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer,TLAB）。不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。在本章中，我们仅仅针对内存区域的作用进行讨论，Java堆中的上述各个区域的分配、回收等细节将是第3章的主题。</p>
<p>&emsp;&emsp;根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。（延伸阅读：<a href="http://unixboy.iteye.com/blog/174173/" target="_blank" rel="external">-Xmx、-Xms</a>）</p>
<h3 id="2-2-5-方法区"><a href="#2-2-5-方法区" class="headerlink" title="2.2.5　方法区"></a>2.2.5　方法区</h3><p>&emsp;&emsp;方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它<strong>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p>
<p>&emsp;&emsp;对于习惯在HotSpot虚拟机上开发、部署程序的开发者来说，很多人都更愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。原则上，如何实现方法区属于虚拟机实现细节，不受虚拟机规范约束，但使用永久代来实现方法区，现在看来并不是一个好主意，因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize的上限，J9和JRockit只要没有触碰到进程可用内存的上限，例如32位系统中的4GB，就不会出现问题），而且有极少数方法（例如String.intern()）会因这个原因导致不同虚拟机下有不同的表现。因此，对于HotSpot虚拟机，根据官方发布的路线图信息，现在也有放弃永久代并逐步改为采用Native Memory来实现方法区的规划了[1]，在目前已经发布的JDK 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出。</p>
<p>&emsp;&emsp;Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说，这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。</p>
<p>&emsp;&emsp;根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>
<h3 id="2-2-6-运行时常量池"><a href="#2-2-6-运行时常量池" class="headerlink" title="2.2.6　运行时常量池"></a>2.2.6　运行时常量池</h3><p>&emsp;&emsp;运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p>
<p>&emsp;&emsp;Java虚拟机对Class文件每一部分（自然也包括常量池）的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、装载和执行，但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中[1]。</p>
<p>&emsp;&emsp;运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>
<p>&emsp;&emsp;既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>
<h3 id="2-2-7-直接内存"><a href="#2-2-7-直接内存" class="headerlink" title="2.2.7　直接内存"></a>2.2.7　直接内存</h3><p>&emsp;&emsp;直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，所以我们放到这里一起讲解。</p>
<p>&emsp;&emsp;在JDK 1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>
<p>&emsp;&emsp;显然，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，肯定还是会受到本机总内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h2 id="2-3-HotSpot虚拟机对象探秘"><a href="#2-3-HotSpot虚拟机对象探秘" class="headerlink" title="2.3　HotSpot虚拟机对象探秘"></a>2.3　HotSpot虚拟机对象探秘</h2><p>&emsp;&emsp;介绍完Java虚拟机的运行时数据区之后，我们大致知道了虚拟机内存的概况，读者了解了内存中放了些什么后，也许就会想更进一步了解这些虚拟机内存中的数据的其他细节，譬如它们是如何创建、如何布局以及如何访问的。对于这样涉及细节的问题，必须把讨论范围限定在具体的虚拟机和集中在某一个内存区域上才有意义。基于实用优先的原则，笔者以常用的虚拟机HotSpot和常用的内存区域Java堆为例，深入探讨HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
<h3 id="2-3-1-对象的创建"><a href="#2-3-1-对象的创建" class="headerlink" title="2.3.1　对象的创建"></a>2.3.1　对象的创建</h3><p>&emsp;&emsp;Java是一门面向对象的编程语言，在Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象（例如克隆、反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？</p>
<p>&emsp;&emsp;虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，本书第7章将探讨这部分内容的细节。</p>
<p>&emsp;&emsp;在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（如何确定将在2.3.2节中介绍），为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p>
<p>&emsp;&emsp;除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</p>
<p>&emsp;&emsp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<p>&emsp;&emsp;接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。关于对象头的具体内容，稍后再做详细介绍。</p>
<p>&emsp;&emsp;在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——＜init＞方法还没有执行，所有的字段都还为零。所以，一般来说（由字节码中是否跟随invokespecial指令所决定），执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<p>&emsp;&emsp;下面的代码清单2-1是HotSpot虚拟机bytecodeInterpreter.cpp中的代码片段（这个解释器实现很少有机会实际使用，因为大部分平台上都使用模板解释器；当代码通过JIT编译器执行时差异就更大了。不过，这段代码用于了解HotSpot的运作过程是没有什么问题的）。</p>
<p>&emsp;&emsp;代码清单2-1　HotSpot解释器的代码片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//确保常量池中存放的是已解释的类</span></div><div class="line"><span class="keyword">if</span>（!constants-＞tag_at（index）.is_unresolved_klass()）&#123;</div><div class="line"><span class="comment">//断言确保是klassOop和instanceKlassOop（这部分下一节介绍）</span></div><div class="line">oop entry=（klassOop）*constants-＞obj_at_addr（index）；</div><div class="line"><span class="keyword">assert</span>（entry-＞is_klass()，<span class="string">"Should be resolved klass"</span>）；</div><div class="line">klassOop k_entry=（klassOop）entry；</div><div class="line"><span class="keyword">assert</span>（k_entry-＞klass_part()-＞oop_is_instance()，<span class="string">"Should be instanceKlass"</span>）；</div><div class="line">instanceKlass * ik=（instanceKlass*）k_entry-＞klass_part()；</div><div class="line"><span class="comment">//确保对象所属类型已经经过初始化阶段</span></div><div class="line"><span class="keyword">if</span>（ik-＞is_initialized()＆＆ik-＞can_be_fastpath_allocated()）</div><div class="line">&#123;</div><div class="line"><span class="comment">//取对象长度</span></div><div class="line">size_t obj_size=ik-＞size_helper()；</div><div class="line">oop result=NULL；</div><div class="line"><span class="comment">//记录是否需要将对象所有字段置零值</span></div><div class="line">bool need_zero=!ZeroTLAB；</div><div class="line"><span class="comment">//是否在TLAB中分配对象</span></div><div class="line"><span class="keyword">if</span>（UseTLAB）&#123;</div><div class="line">result=（oop）THREAD-＞tlab().allocate（obj_size）；</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>（result==NULL）&#123;</div><div class="line">need_zero=<span class="keyword">true</span>；</div><div class="line"><span class="comment">//直接在eden中分配对象</span></div><div class="line">retry:</div><div class="line">HeapWord * compare_to=*Universe:heap()-＞top_addr()；</div><div class="line">HeapWord * new_top=compare_to+obj_size；</div><div class="line"><span class="comment">/*cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，如果并发失败，</span></div><div class="line">转到retry中重试，直至成功分配为止*/</div><div class="line"><span class="keyword">if</span>（new_top＜=*Universe:heap()-＞end_addr()）&#123;</div><div class="line"><span class="keyword">if</span>（Atomic:cmpxchg_ptr（new_top,Universe:heap()-＞top_addr()，compare_to）!=compare_to）&#123;</div><div class="line">goto retry；</div><div class="line">&#125;</div><div class="line">result=（oop）compare_to；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>（result!=NULL）&#123;</div><div class="line"><span class="comment">//如果需要，则为对象初始化零值</span></div><div class="line"><span class="keyword">if</span>（need_zero）&#123;</div><div class="line">HeapWord * to_zero=（HeapWord*）result+sizeof（oopDesc）/oopSize；</div><div class="line">obj_size-=sizeof（oopDesc）/oopSize；</div><div class="line"><span class="keyword">if</span>（obj_size＞<span class="number">0</span>）&#123;</div><div class="line">memset（to_zero，<span class="number">0</span>，obj_size * HeapWordSize）；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//根据是否启用偏向锁来设置对象头信息</span></div><div class="line"><span class="keyword">if</span>（UseBiasedLocking）&#123;</div><div class="line">result-＞set_mark（ik-＞prototype_header()）；</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">result-＞set_mark（markOopDesc:prototype()）；</div><div class="line">&#125;</div><div class="line">result-＞set_klass_gap（<span class="number">0</span>）；</div><div class="line">result-＞set_klass（k_entry）；</div><div class="line"><span class="comment">//将对象引用入栈，继续执行下一条指令</span></div><div class="line">SET_STACK_OBJECT（result，<span class="number">0</span>）；</div><div class="line">UPDATE_PC_AND_TOS_AND_CONTINUE（<span class="number">3</span>，<span class="number">1</span>）；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>根据对象的创建流程画的一个流程图：</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05111725_lmwh.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h3 id="2-3-2-对象的内存布局"><a href="#2-3-2-对象的内存布局" class="headerlink" title="2.3.2　对象的内存布局"></a>2.3.2　对象的内存布局</h3><p>&emsp;&emsp;在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p>
<p>&emsp;&emsp;HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为”Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32位、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定为0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表2-1。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05101804_ybW2.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。</p>
<p>&emsp;&emsp;代码清单2-2为HotSpot虚拟机markOop.cpp中的代码（注释）片段，它描述了32bit下Mark Word的存储状态。</p>
<p>&emsp;&emsp;代码清单2-2　markOop.cpp片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Bit-format of an object header（most significant first,big endian layout below）:</span></div><div class="line"><span class="comment">//32 bits:</span></div><div class="line"><span class="comment">//--------</span></div><div class="line"><span class="comment">//hash:25------------＞|age:4 biased_lock:1 lock:2（normal object）</span></div><div class="line"><span class="comment">//JavaThread*:23 epoch:2 age:4 biased_lock:1 lock:2（biased object）</span></div><div class="line"><span class="comment">//size:32------------------------------------------＞|（CMS free block）</span></div><div class="line"><span class="comment">//PromotedObject*:29----------＞|promo_bits:3-----＞|（CMS promoted object）</span></div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来的实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p>
<p>&emsp;&emsp;第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05115013_wQq9.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h3 id="2-3-3-对象的访问定位"><a href="#2-3-3-对象的访问定位" class="headerlink" title="2.3.3　对象的访问定位"></a>2.3.3　对象的访问定位</h3><p>&emsp;&emsp;建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。</p>
<p>&emsp;&emsp;如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如图2-2所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05102012_MZL8.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址，如图2-3所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05102041_r0k5.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p>
<p>&emsp;&emsp;使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p>
<h2 id="2-4-实战：OutOfMemoryError异常"><a href="#2-4-实战：OutOfMemoryError异常" class="headerlink" title="2.4　实战：OutOfMemoryError异常"></a>2.4　实战：OutOfMemoryError异常</h2><p>&emsp;&emsp;在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（下文称OOM）异常的可能，本节将通过若干实例来验证异常发生的场景（代码清单2-3～代码清单2-9的几段简单代码），并且会初步介绍几个与内存相关的最基本的虚拟机参数。</p>
<p>&emsp;&emsp;本节内容的目的有两个：第一，通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容；第二，希望读者在工作中遇到实际的内存溢出异常时，能根据异常的信息快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常后该如何处理。</p>
<p>&emsp;&emsp;下文代码的开头都注释了执行时所需要设置的虚拟机启动参数（注释中”VM Args”后面跟着的参数），这些参数对实验的结果有直接影响，读者调试代码的时候千万不要忽略。如果读者使用控制台命令来执行程序，那直接跟在Java命令之后书写就可以。如果读者使用Eclipse IDE，则可以参考图2-4在Debug/Run页签中的设置。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05102204_84A5.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;下文的代码都是基于Sun公司的HotSpot虚拟机运行的，对于不同公司的不同版本的虚拟机，参数和程序运行的结果可能会有所差别。</p>
<h3 id="2-4-1-Java堆溢出"><a href="#2-4-1-Java堆溢出" class="headerlink" title="2.4.1　Java堆溢出"></a>2.4.1　Java堆溢出</h3><p>&emsp;&emsp;Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p>
<p>&emsp;&emsp;代码清单2-3中代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析[1]。</p>
<p>&emsp;&emsp;代码清单2-3　Java堆内存溢出异常测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*VM Args:-Xms20m-Xmx20m-XX:+HeapDumpOnOutOfMemoryError</div><div class="line">*<span class="doctag">@author</span> zzm</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span></span>&#123;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</div><div class="line">List＜OOMObject＞list=<span class="keyword">new</span> ArrayList＜OOMObject＞()；</div><div class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</div><div class="line">list.add（<span class="keyword">new</span> OOMObject()）；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">java.lang.OutOfMemoryError:Java heap space</div><div class="line">Dumping heap to java_pid3404.hprof……</div><div class="line">Heap dump file created[<span class="number">22045981</span> bytes in <span class="number">0.663</span> secs]</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息”java.lang.OutOfMemoryError”会跟着进一步提示”Java heap space”。</p>
<p>&emsp;&emsp;要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。图2-5显示了使用Eclipse Memory Analyzer打开的堆转储快照文件。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05102429_GXZN.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。</p>
<p>&emsp;&emsp;如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<p>&emsp;&emsp;以上是处理Java堆内存问题的简单思路，处理这些问题所需要的知识、工具与经验是后面3章的主题。</p>
<h3 id="2-4-2-虚拟机栈和本地方法栈溢出"><a href="#2-4-2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2.4.2　虚拟机栈和本地方法栈溢出"></a>2.4.2　虚拟机栈和本地方法栈溢出</h3><p>&emsp;&emsp;由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，但实际上是无效的，栈容量只由-Xss参数设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：</p>
<p>&emsp;&emsp;如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</p>
<p>&emsp;&emsp;如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常。</p>
<p>&emsp;&emsp;这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。</p>
<p>&emsp;&emsp;在笔者的实验中，将实验范围限制于单线程中的操作，尝试了下面两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常，测试代码如代码清单2-4所示。</p>
<p>&emsp;&emsp;使用-Xss参数减少栈内存容量。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</p>
<p>&emsp;&emsp;定义了大量的本地变量，增大此方法帧中本地变量表的长度。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。</p>
<p>&emsp;&emsp;代码清单2-4　虚拟机栈和本地方法栈OOM测试（仅作为第1点测试程序）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*VM Args:-Xss128k</div><div class="line">*<span class="doctag">@author</span> zzm</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> stackLength=<span class="number">1</span>；</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span></span>&#123;</div><div class="line">stackLength++；</div><div class="line">stackLeak()；</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）<span class="keyword">throws</span> Throwable&#123;</div><div class="line">JavaVMStackSOF oom=<span class="keyword">new</span> JavaVMStackSOF()；</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">oom.stackLeak()；</div><div class="line">&#125;<span class="keyword">catch</span>（Throwable e）&#123;</div><div class="line">System.out.println（<span class="string">"stack length:"</span>+oom.stackLength）；</div><div class="line"><span class="keyword">throw</span> e；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stack length:<span class="number">2402</span></div><div class="line">Exception in thread<span class="string">"main"</span>java.lang.StackOverflowError</div><div class="line">at org.fenixsoft.oom.VMStackSOF.leak（VMStackSOF.java:<span class="number">20</span>）</div><div class="line">at org.fenixsoft.oom.VMStackSOF.leak（VMStackSOF.java:<span class="number">21</span>）</div><div class="line">at org.fenixsoft.oom.VMStackSOF.leak（VMStackSOF.java:<span class="number">21</span>）</div><div class="line">……后续异常堆栈信息省略</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。</p>
<p>&emsp;&emsp;如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常，如代码清单2-5所示。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</p>
<p>&emsp;&emsp;其实原因不难理解，操作系统分配给每个进程的内存是有限制的，譬如32位的Windows限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB（操作系统限制）减去Xmx（最大堆容量），再减去MaxPermSize（最大方法区容量），程序计数器消耗内存很小，可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内，剩下的内存就由虚拟机栈和本地方法栈“瓜分”了。每个线程分配到的栈容量越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。</p>
<p>&emsp;&emsp;这一点读者需要在开发多线程的应用时特别注意，出现StackOverflowError异常时有错误堆栈可以阅读，相对来说，比较容易找到问题的所在。而且，如果使用虚拟机默认参数，栈深度在大多数情况下（因为每个方法压入栈的帧大小并不是一样的，所以只能说在大多数情况下）达到1000～2000完全没有问题，对于正常的方法调用（包括递归），这个深度应该完全够用了。但是，如果是建立过多线程导致的内存溢出，在不能减少线程数或者更换64位虚拟机的情况下，就只能通过减少最大堆和减少栈容量来换取更多的线程。如果没有这方面的处理经验，这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。</p>
<p>&emsp;&emsp;代码清单2-5　创建线程导致内存溢出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*VM Args:-Xss2M（这时候不妨设置大些）</div><div class="line">*<span class="doctag">@author</span> zzm</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</div><div class="line">Thread thread=<span class="keyword">new</span> Thread（<span class="keyword">new</span> Runnable()&#123;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">dontStop()；</div><div class="line">&#125;</div><div class="line">&#125;）；</div><div class="line">thread.start()；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）<span class="keyword">throws</span> Throwable&#123;</div><div class="line">JavaVMStackOOM oom=<span class="keyword">new</span> JavaVMStackOOM()；</div><div class="line">oom.stackLeakByThread()；</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;注意　特别提示一下，如果读者要尝试运行上面这段代码，记得要先保存当前的工作。由于在Windows平台的虚拟机中，Java的线程是映射到操作系统的内核线程上的[1]，因此上述代码执行时有较大的风险，可能会导致操作系统假死。</p>
<p>&emsp;&emsp;运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exception in thread<span class="string">"main"</span>java.lang.OutOfMemoryError:unable to create <span class="keyword">new</span> <span class="keyword">native</span> thread</div></pre></td></tr></table></figure></p>
<h3 id="2-4-3-方法区和运行时常量池溢出"><a href="#2-4-3-方法区和运行时常量池溢出" class="headerlink" title="2.4.3　方法区和运行时常量池溢出"></a>2.4.3　方法区和运行时常量池溢出</h3><p>&emsp;&emsp;由于运行时常量池是方法区的一部分，因此这两个区域的溢出测试就放在一起进行。前面提到JDK 1.7开始逐步“去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。</p>
<p>&emsp;&emsp;String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量，如代码清单2-6所示。</p>
<p>&emsp;&emsp;代码清单2-6　运行时常量池导致的内存溢出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*VM Args:-XX:PermSize=10M-XX:MaxPermSize=10M</div><div class="line">*<span class="doctag">@author</span> zzm</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</div><div class="line"><span class="comment">//使用List保持着常量池引用，避免Full GC回收常量池行为</span></div><div class="line">List＜String＞list=<span class="keyword">new</span> ArrayList＜String＞()；</div><div class="line"><span class="comment">//10MB的PermSize在integer范围内足够产生OOM了</span></div><div class="line"><span class="keyword">int</span> i=<span class="number">0</span>；</div><div class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</div><div class="line">list.add（String.valueOf（i++）.intern()）；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception in thread<span class="string">"main"</span>java.lang.OutOfMemoryError:PermGen space</div><div class="line">at java.lang.String.intern（Native Method）</div><div class="line">at org.fenixsoft.oom.RuntimeConstantPoolOOM.main（RuntimeConstantPoolOOM.java:<span class="number">18</span>）</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从运行结果中可以看到，运行时常量池溢出，在OutOfMemoryError后面跟随的<strong>提示信息是”PermGen space”，说明运行时常量池属于方法区</strong>（HotSpot虚拟机中的永久代）的一部分。</p>
<p>&emsp;&emsp;而使用JDK 1.7运行这段程序就不会得到相同的结果，while循环将一直进行下去。关于这个字符串常量池的实现问题，还可以引申出一个更有意思的影响，如代码清单2-7所示。</p>
<p>&emsp;&emsp;代码清单2-7　String.intern()返回引用的测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</div><div class="line">String str1=<span class="keyword">new</span> StringBuilder（<span class="string">"计算机"</span>）.append（<span class="string">"软件"</span>）.toString()；</div><div class="line">System.out.println（str1.intern()==str1）；</div><div class="line">String str2=<span class="keyword">new</span> StringBuilder（<span class="string">"ja"</span>）.append（<span class="string">"va"</span>）.toString()；</div><div class="line">System.out.println（str2.intern()==str2）；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。产生差异的原因是：在JDK 1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。而JDK 1.7（以及部分其他虚拟机，例如JRockit）的intern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。对str2比较返回false是因为”java”这个字符串在执行StringBuilder.toString()之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</p>
<p>&emsp;&emsp;方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。虽然直接使用Java SE API也可以动态产生类（如反射时的GeneratedConstructorAccessor和动态代理等），但在本次实验中操作起来比较麻烦。在代码清单2-8中，笔者借助CGLib[1]直接操作字节码运行时生成了大量的动态类。</p>
<p>&emsp;&emsp;值得特别注意的是，我们在这个例子中模拟的场景并非纯粹是一个实验，这样的应用经常会出现在实际应用中：当前的很多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。另外，JVM上的动态语言（例如Groovy等）通常都会持续创建类来实现语言的动态性，随着这类语言的流行，也越来越容易遇到与代码清单2-8相似的溢出场景。</p>
<p>&emsp;&emsp;代码清单2-8　借助CGLib使方法区出现内存溢出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*VM Args:-XX:PermSize=10M-XX:MaxPermSize=10M</div><div class="line">*<span class="doctag">@author</span> zzm</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span></span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）&#123;</div><div class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</div><div class="line">Enhancer enhancer=<span class="keyword">new</span> Enhancer()；</div><div class="line">enhancer.setSuperclass（OOMObject.class）；</div><div class="line">enhancer.setUseCache（<span class="keyword">false</span>）；</div><div class="line">enhancer.setCallback（<span class="keyword">new</span> MethodInterceptor()&#123;</div><div class="line"><span class="keyword">public</span> Object intercept（Object obj,Method method,Object[]args,MethodProxy proxy）<span class="keyword">throws</span> Throwable&#123;</div><div class="line"><span class="keyword">return</span> proxy.invokeSuper（obj,args）；</div><div class="line">&#125;</div><div class="line">&#125;）；</div><div class="line">enhancer.create()；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Caused by:java.lang.OutOfMemoryError:PermGen space</div><div class="line">at java.lang.ClassLoader.defineClass1（Native Method）</div><div class="line">at java.lang.ClassLoader.defineClassCond（ClassLoader.java:<span class="number">632</span>）</div><div class="line">at java.lang.ClassLoader.defineClass（ClassLoader.java:<span class="number">616</span>）</div><div class="line">……<span class="number">8</span> more</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了上面提到的程序使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
<h3 id="2-4-4-本机直接内存溢出"><a href="#2-4-4-本机直接内存溢出" class="headerlink" title="2.4.4　本机直接内存溢出"></a>2.4.4　本机直接内存溢出</h3><p>&emsp;&emsp;DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，则默认与Java堆最大值（-Xmx指定）一样，代码清单2-9越过了DirectByteBuffer类，直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能）。因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是unsafe.allocateMemory()。</p>
<p>&emsp;&emsp;代码清单2-9　使用unsafe分配本机内存<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*VM Args:-Xmx20M-XX:MaxDirectMemorySize=10M</div><div class="line">*<span class="doctag">@author</span> zzm</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span></span>&#123;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>；</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（String[]args）<span class="keyword">throws</span> Exception&#123;</div><div class="line">Field unsafeField=Unsafe.class.getDeclaredFields()[<span class="number">0</span>]；</div><div class="line">unsafeField.setAccessible（<span class="keyword">true</span>）；</div><div class="line">Unsafe unsafe=（Unsafe）unsafeField.get（<span class="keyword">null</span>）；</div><div class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</div><div class="line">unsafe.allocateMemory（_1MB）；</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception in thread<span class="string">"main"</span>java.lang.OutOfMemoryError</div><div class="line">at sun.misc.Unsafe.allocateMemory（Native Method）</div><div class="line">at org.fenixsoft.oom.DMOOM.main（DMOOM.java:<span class="number">20</span>）</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>
<h2 id="2-5-本章小结"><a href="#2-5-本章小结" class="headerlink" title="2.5　本章小结"></a>2.5　本章小结</h2><p>&emsp;&emsp;通过本章的学习，我们明白了虚拟机中的内存是如何划分的，哪部分区域、什么样的代码和操作可能导致内存溢出异常。虽然Java有垃圾收集机制，但内存溢出异常离我们仍然并不遥远，本章只是讲解了各个区域出现内存溢出异常的原因，第3章将详细讲解Java垃圾收集机制为了避免内存溢出异常的出现都做了哪些努力。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/06/3-垃圾收集器与内存分配策略/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/06/3-垃圾收集器与内存分配策略/" itemprop="url">
                  3. 垃圾收集器与内存分配策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-06T17:40:22+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1　概述"></a>3.1　概述</h1><p>&emsp;&emsp;说起垃圾收集（Garbage Collection,GC），大部分人都把这项技术当做Java语言的伴生产物。事实上，GC的历史比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的3件事情：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>&emsp;&emsp;经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p>
<p>&emsp;&emsp;把时间从半个多世纪以前拨回到现在，回到我们熟悉的Java语言。第2章介绍了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的（尽管在运行期会由JIT编译器进行一些优化，但在本章基于概念模型的讨论中，大体上可以认为是编译期可知的），因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，本章后续讨论中的“内存”分配与回收也仅指这一部分内存。</p>
<h1 id="3-2-对象已死吗"><a href="#3-2-对象已死吗" class="headerlink" title="3.2　对象已死吗"></a>3.2　对象已死吗</h1><p>&emsp;&emsp;在堆里面存放着Java世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。</p>
<h2 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1　引用计数算法"></a>3.2.1　引用计数算法</h2><p>&emsp;&emsp;很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。作者面试过很多的应届生和一些有多年工作经验的开发人员，他们对于这个问题给予的都是这个答案。</p>
<p>&emsp;&emsp;客观地说，引用计数算法（Reference Counting）的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软公司的COM（Component Object Model）技术、使用ActionScript 3的FlashPlayer、Python语言和在游戏脚本领域被广泛应用的Squirrel中都使用了引用计数算法进行内存管理。但是，至少主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
<p>&emsp;&emsp;举个简单的例子，请看代码清单3-1中的testGC()方法：对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。</p>
<p>&emsp;&emsp;代码清单3-1　引用计数算法的缺陷<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * testGC()方法执行后，objA和objB会不会被GC呢？ </div><div class="line"> * <span class="doctag">@author</span> zzm</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</div><div class="line">		ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</div><div class="line">		ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</div><div class="line">		objA.instance = objB;</div><div class="line">		objB.instance = objA;</div><div class="line"></div><div class="line">		objA = <span class="keyword">null</span>;</div><div class="line">		objB = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></div><div class="line">		System.gc();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[Full GC（System）[Tenured:<span class="number">0</span>K-＞<span class="number">210</span>K（<span class="number">10240</span>K），<span class="number">0.0149142</span> secs]<span class="number">4603</span>K-＞<span class="number">210</span>K（<span class="number">19456</span>K），[Perm:<span class="number">2999</span>K-＞<span class="number">2999</span>K（<span class="number">21248</span>K）]，<span class="number">0.0150007</span> secs][Times:user=<span class="number">0.01</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</div><div class="line">Heap</div><div class="line">def <span class="keyword">new</span> generation total <span class="number">9216</span>K,used <span class="number">82</span>K[<span class="number">0x00000000055e0000</span>，<span class="number">0x0000000005fe0000</span>，<span class="number">0x0000000005fe0000</span>）</div><div class="line">Eden space <span class="number">8192</span>K，<span class="number">1</span>%used[<span class="number">0x00000000055e0000</span>，<span class="number">0x00000000055f4850</span>，<span class="number">0x0000000005de0000</span>）</div><div class="line">from space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x0000000005de0000</span>，<span class="number">0x0000000005de0000</span>，<span class="number">0x0000000005ee0000</span>）</div><div class="line">to space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x0000000005ee0000</span>，<span class="number">0x0000000005ee0000</span>，<span class="number">0x0000000005fe0000</span>）</div><div class="line">tenured generation total <span class="number">10240</span>K,used <span class="number">210</span>K[<span class="number">0x0000000005fe0000</span>，<span class="number">0x00000000069e0000</span>，<span class="number">0x00000000069e0000</span>）</div><div class="line">the space <span class="number">10240</span>K，<span class="number">2</span>%used[<span class="number">0x0000000005fe0000</span>，<span class="number">0x0000000006014a18</span>，<span class="number">0x0000000006014c00</span>，<span class="number">0x00000000069e0000</span>）</div><div class="line">compacting perm gen total <span class="number">21248</span>K,used <span class="number">3016</span>K[<span class="number">0x00000000069e0000</span>，<span class="number">0x0000000007ea0000</span>，<span class="number">0x000000000bde0000</span>）</div><div class="line">the space <span class="number">21248</span>K，<span class="number">14</span>%used[<span class="number">0x00000000069e0000</span>，<span class="number">0x0000000006cd2398</span>，<span class="number">0x0000000006cd2400</span>，<span class="number">0x0000000007ea0000</span>）</div><div class="line">No shared spaces configured.</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从运行结果中可以清楚看到，GC日志中包含”4603K-＞210K”，意味着虚拟机并没有因为这两个对象互相引用就不回收它们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>
<h2 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2　可达性分析算法"></a>3.2.2　可达性分析算法</h2><p>&emsp;&emsp;在主流的商用程序语言（Java、C#，甚至包括前面提到的古老的Lisp）的主流实现中，都是称通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路就是通过一系列的称为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。如图3-1所示，对象object 5、object 6、object 7虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05145222_v3K7.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
<h2 id="3-2-3-再谈引用"><a href="#3-2-3-再谈引用" class="headerlink" title="3.2.3　再谈引用"></a>3.2.3　再谈引用</h2><p>&emsp;&emsp;无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在JDK 1.2以前，Java中的引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但是太过狭隘，一个对象在这种定义下只有被引用或者没有被引用两种状态，对于如何描述一些“食之无味，弃之可惜”的对象就显得无能为力。我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p>
<p>&emsp;&emsp;在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度依次逐渐减弱。</p>
<p>&emsp;&emsp;强引用就是指在程序代码之中普遍存在的，类似”Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p>
<p>&emsp;&emsp;<strong>软引用</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，<strong>在系统将要发生内存溢出异常之前</strong>，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p>
<p>&emsp;&emsp;<strong>弱引用</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，<strong>被弱引用关联的对象只能生存到下一次垃圾收集发生之前</strong>。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p>
<p>&emsp;&emsp;<strong>虚引用</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。<strong>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p>
<h2 id="3-2-4-生存还是死亡"><a href="#3-2-4-生存还是死亡" class="headerlink" title="3.2.4　生存还是死亡"></a>3.2.4　生存还是死亡</h2><p>&emsp;&emsp;即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>&emsp;&emsp;如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。从代码清单3-2中我们可以看到一个对象的finalize()被执行，但是它仍然可以存活。</p>
<p>&emsp;&emsp;代码清单3-2　一次对象自我拯救的演示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 此代码演示了两点： </div><div class="line"> * 1.对象可以在被GC时自我拯救。 </div><div class="line"> * 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次</div><div class="line"> * <span class="doctag">@author</span> zzm</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"yes, i am still alive :)"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		<span class="keyword">super</span>.finalize();</div><div class="line">		System.out.println(<span class="string">"finalize mehtod executed!"</span>);</div><div class="line">		FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">		SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</div><div class="line"></div><div class="line">		<span class="comment">//对象第一次成功拯救自己</span></div><div class="line">		SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">		System.gc();</div><div class="line">		<span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></div><div class="line">		Thread.sleep(<span class="number">500</span>);</div><div class="line">		<span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">			SAVE_HOOK.isAlive();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			System.out.println(<span class="string">"no, i am dead :("</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></div><div class="line">		SAVE_HOOK = <span class="keyword">null</span>;</div><div class="line">		System.gc();</div><div class="line">		<span class="comment">// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span></div><div class="line">		Thread.sleep(<span class="number">500</span>);</div><div class="line">		<span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</div><div class="line">			SAVE_HOOK.isAlive();</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			System.out.println(<span class="string">"no, i am dead :("</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">finalize mehtod executed!</div><div class="line">yes,i am still alive:）</div><div class="line">no,i am dead:（</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从代码清单3-2的运行结果可以看出，SAVE_HOOK对象的finalize()方法确实被GC收集器触发过，并且在被收集前成功逃脱了。</p>
<p>&emsp;&emsp;另外一个值得注意的地方是，代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败，这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行</strong>，因此第二段代码的自救行动失败了。</p>
<p>&emsp;&emsp;需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，笔者并不鼓励大家使用这种方法来拯救对象。相反，笔者建议大家尽量避免使用它，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中描述它适合做“关闭外部资源”之类的工作，这完全是对这个方法用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言中有这个方法的存在。</p>
<h2 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5　回收方法区"></a>3.2.5　回收方法区</h2><p>&emsp;&emsp;很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。</p>
<p>&emsp;&emsp;永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”abc”的，换句话说，就是没有任何String对象引用常量池中的”abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个”abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>&emsp;&emsp;判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>&emsp;&emsp;虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p>
<p>&emsp;&emsp;在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h1 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3　垃圾收集算法"></a>3.3　垃圾收集算法</h1><p>&emsp;&emsp;由于垃圾收集算法的实现涉及大量的程序细节，而且各个平台的虚拟机操作内存的方法又各不相同，因此本节不打算过多地讨论算法的实现，只是介绍几种算法的思想及其发展过程。</p>
<h2 id="3-3-1-标记-清除算法"><a href="#3-3-1-标记-清除算法" class="headerlink" title="3.3.1　标记-清除算法"></a>3.3.1　标记-清除算法</h2><p>&emsp;&emsp;最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记—清除算法的执行过程如图3-2所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05145726_3I3d.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h2 id="3-3-2-复制算法"><a href="#3-3-2-复制算法" class="headerlink" title="3.3.2　复制算法"></a>3.3.2　复制算法</h2><p>&emsp;&emsp;为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。复制算法的执行过程如图3-3所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05145821_K8e0.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor[1]。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<p>&emsp;&emsp;内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。关于对新生代进行分配担保的内容，在本章稍后在讲解垃圾收集器执行规则时还会再详细讲解。</p>
<h2 id="3-3-3-标记-整理算法"><a href="#3-3-3-标记-整理算法" class="headerlink" title="3.3.3　标记-整理算法"></a>3.3.3　标记-整理算法</h2><p>&emsp;&emsp;复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>&emsp;&emsp;根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，“标记-整理”算法的示意图如图3-4所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05145932_0Crk.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h2 id="3-3-4-分代收集算法"><a href="#3-3-4-分代收集算法" class="headerlink" title="3.3.4　分代收集算法"></a>3.3.4　分代收集算法</h2><p>&emsp;&emsp;当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
<h1 id="3-4-HotSpot的算法实现"><a href="#3-4-HotSpot的算法实现" class="headerlink" title="3.4　HotSpot的算法实现"></a>3.4　HotSpot的算法实现</h1><p>&emsp;&emsp;3.2节和3.3节从理论上介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。</p>
<h2 id="3-4-1-枚举根节点"><a href="#3-4-1-枚举根节点" class="headerlink" title="3.4.1　枚举根节点"></a>3.4.1　枚举根节点</h2><p>&emsp;&emsp;从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p>
<p>&emsp;&emsp;另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为”Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<p>&emsp;&emsp;由于目前的主流Java虚拟机使用的都是准确式GC（这个概念在第1章介绍Exact VM对Classic VM的改进时讲过），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。下面的代码清单3-3是HotSpot Client VM生成的一段String.hashCode()方法的本地代码，可以看到在0x026eb7a9处的call指令有OopMap记录，它指明了EBX寄存器和栈中偏移量为16的内存区域中各有一个普通对象指针（Ordinary Object Pointer）的引用，有效范围为从call指令开始直到0x026eb730（指令流的起始位置）+142（OopMap记录的偏移量）=0x026eb7be，即hlt指令为止。</p>
<p>&emsp;&emsp;代码清单3-3　String.hashCode()方法编译后的本地代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[Verified Entry Point]</div><div class="line"><span class="number">0x026eb730</span>:mov%eax，-<span class="number">0x8000</span>（%esp）</div><div class="line">……</div><div class="line">；ImplicitNullCheckStub slow <span class="keyword">case</span></div><div class="line"><span class="number">0x026eb7a9</span>:call <span class="number">0x026e83e0</span></div><div class="line">；OopMap&#123;ebx=Oop[<span class="number">16</span>]=Oop off=<span class="number">142</span>&#125;</div><div class="line">；*caload</div><div class="line">；-java.lang.String:hashCode@<span class="number">48</span>（line <span class="number">1489</span>）</div><div class="line">；&#123;runtime_call&#125;</div><div class="line"><span class="number">0x026eb7ae</span>:push$<span class="number">0x83c5c18</span></div><div class="line">；&#123;external_word&#125;</div><div class="line"><span class="number">0x026eb7b3</span>:call <span class="number">0x026eb7b8</span></div><div class="line"><span class="number">0x026eb7b8</span>:pusha</div><div class="line"><span class="number">0x026eb7b9</span>:call <span class="number">0x0822bec0</span>；&#123;runtime_call&#125;</div><div class="line"><span class="number">0x026eb7be</span>:hlt</div></pre></td></tr></table></figure></p>
<h2 id="3-4-2-安全点"><a href="#3-4-2-安全点" class="headerlink" title="3.4.2　安全点"></a>3.4.2　安全点</h2><p>&emsp;&emsp;在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</p>
<p>&emsp;&emsp;实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<p>&emsp;&emsp;对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来。这里有两种方案可供选择：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension），其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p>
<p>&emsp;&emsp;而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。下面代码清单3-4中的test指令是HotSpot生成的轮询指令，当需要暂停线程时，虚拟机把0x160100的内存页设置为不可读，线程执行到test指令时就会产生一个自陷异常信号，在预先注册的异常处理器中暂停线程实现等待，这样一条汇编指令便完成安全点轮询和触发线程中断。</p>
<p>&emsp;&emsp;代码清单3-4　轮询指令<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x01b6d627</span>:call <span class="number">0x01b2b210</span>；OopMap&#123;[<span class="number">60</span>]=Oop off=<span class="number">460</span>&#125;</div><div class="line">；*invokeinterface size</div><div class="line">；-Client1:main@<span class="number">113</span>（line <span class="number">23</span>）</div><div class="line">；&#123;virtual_call&#125;</div><div class="line"><span class="number">0x01b6d62c</span>:nop</div><div class="line">；OopMap&#123;[<span class="number">60</span>]=Oop off=<span class="number">461</span>&#125;</div><div class="line">；*if_icmplt</div><div class="line">；-Client1:main@<span class="number">118</span>（line <span class="number">23</span>）</div><div class="line"><span class="number">0x01b6d62d</span>:test%eax，<span class="number">0x160100</span>；&#123;poll&#125;</div><div class="line"><span class="number">0x01b6d633</span>:mov <span class="number">0x50</span>（%esp），%esi</div><div class="line"><span class="number">0x01b6d637</span>:cmp%eax，%esi</div></pre></td></tr></table></figure></p>
<h2 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3　安全区域"></a>3.4.3　安全区域</h2><p>&emsp;&emsp;使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p>&emsp;&emsp;安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p>
<p>&emsp;&emsp;在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<p>&emsp;&emsp;到此，笔者简要地介绍了HotSpot虚拟机如何去发起内存回收的问题，但是虚拟机如何具体地进行内存回收动作仍然未涉及，因为内存回收如何进行是由虚拟机所采用的GC收集器决定的，而通常虚拟机中往往不止有一种GC收集器。下面继续来看HotSpot中有哪些GC收集器。</p>
<h1 id="3-5-垃圾收集器"><a href="#3-5-垃圾收集器" class="headerlink" title="3.5　垃圾收集器"></a>3.5　垃圾收集器</h1><p>&emsp;&emsp;如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。Java虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。这里讨论的收集器基于JDK 1.7 Update 14之后的HotSpot虚拟机（在这个版本中正式提供了商用的G1收集器，之前G1仍处于实验状态），这个虚拟机包含的所有收集器如图3-5所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05150313_cppm.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;图3-5展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。接下来笔者将逐一介绍这些收集器的特性、基本原理和使用场景，并重点分析CMS和G1这两款相对复杂的收集器，了解它们的部分运作细节。</p>
<p>&emsp;&emsp;在介绍这些收集器各自的特性之前，我们先来明确一个观点：虽然我们是在对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有最好的收集器出现，更加没有万能的收集器，所以我们选择的只是对具体应用最合适的收集器。这点不需要多加解释就能证明：如果有一种放之四海皆准、任何场景下都适用的完美收集器存在，那HotSpot虚拟机就没必要实现那么多不同的收集器了。</p>
<h2 id="3-5-1-Serial收集器"><a href="#3-5-1-Serial收集器" class="headerlink" title="3.5.1　Serial收集器"></a>3.5.1　Serial收集器</h2><p>&emsp;&emsp;Serial收集器是最基本、发展历史最悠久的收集器，曾经（在JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。大家看名字就会知道，这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。”Stop The World”这个名字也许听起来很酷，但这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。读者不妨试想一下，要是你的计算机每运行一个小时就会暂停响应5分钟，你会有什么样的心情？图3-6示意了Serial/Serial Old收集器的运行过程。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05150422_H3Hh.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;对于”Stop The World”带给用户的不良体验，虚拟机的设计者们表示完全理解，但也表示非常委屈：“你妈妈在给你打扫房间的时候，肯定也会让你老老实实地在椅子上或者房间外待着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？”这确实是一个合情合理的矛盾，虽然垃圾收集这项工作听起来和打扫房间属于一个性质的，但实际上肯定还要比打扫房间复杂得多啊！</p>
<p>&emsp;&emsp;从JDK 1.3开始，一直到现在最新的JDK 1.7，HotSpot虚拟机开发团队为消除或者减少工作线程因内存回收而导致停顿的努力一直在进行着，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器的最前沿成果Garbage First（G1）收集器，我们看到了一个个越来越优秀（也越来越复杂）的收集器的出现，用户线程的停顿时间在不断缩短，但是仍然没有办法完全消除（这里暂不包括RTSJ中的收集器）。寻找更优秀的垃圾收集器的工作仍在继续！</p>
<p>&emsp;&emsp;写到这里，笔者似乎已经把Serial收集器描述成一个“老而无用、食之无味弃之可惜”的鸡肋了，但实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收集器。它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>
<h2 id="3-5-2-ParNew收集器"><a href="#3-5-2-ParNew收集器" class="headerlink" title="3.5.2　ParNew收集器"></a>3.5.2　ParNew收集器</h2><p>&emsp;&emsp;ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。ParNew收集器的工作过程如图3-7所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05150527_7xfl.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，用前面那个例子的话来说，就是做到了在你的妈妈打扫房间的时候你还能一边往地上扔纸屑。</p>
<p>&emsp;&emsp;不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作[1]，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。</p>
<p>&emsp;&emsp;ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数与CPU的数量相同，在CPU非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<p>&emsp;&emsp;注意　从ParNew收集器开始，后面还会接触到几款并发和并行的收集器。在大家可能产生疑惑之前，有必要先解释两个名词：并发和并行。这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p>
<ul>
<li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li>
</ul>
<h2 id="3-5-3-Parallel-Scavenge收集器"><a href="#3-5-3-Parallel-Scavenge收集器" class="headerlink" title="3.5.3　Parallel Scavenge收集器"></a>3.5.3　Parallel Scavenge收集器</h2><p>&emsp;&emsp;Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和ParNew都一样，那它有什么特别之处呢？</p>
<p>&emsp;&emsp;Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<p>&emsp;&emsp;停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>
<p>&emsp;&emsp;Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。</p>
<p>&emsp;&emsp;MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值。不过大家不要认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</p>
<p>&emsp;&emsp;GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1/（1+19）），默认值为99，就是允许最大1%（即1/（1+99））的垃圾收集时间。</p>
<p>&emsp;&emsp;由于与吞吐量关系密切，Parallel Scavenge收集器也经常称为“吞吐量优先”收集器。除上述两个参数之外，Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）[1]。如果读者对于收集器运作原来不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio（更关注吞吐量）参数给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。</p>
<h2 id="3-5-4-Serial-Old收集器"><a href="#3-5-4-Serial-Old收集器" class="headerlink" title="3.5.4　Serial Old收集器"></a>3.5.4　Serial Old收集器</h2><p>&emsp;&emsp;Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用[1]，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。这两点都将在后面的内容中详细讲解。Serial Old收集器的工作过程如图3-8所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05150746_078R.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h2 id="3-5-5-Parallel-Old收集器"><a href="#3-5-5-Parallel-Old收集器" class="headerlink" title="3.5.5　Parallel Old收集器"></a>3.5.5　Parallel Old收集器</h2><p>&emsp;&emsp;Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。</p>
<p>&emsp;&emsp;直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。Parallel Old收集器的工作过程如图3-9所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05150832_q2to.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h2 id="3-5-6-CMS收集器"><a href="#3-5-6-CMS收集器" class="headerlink" title="3.5.6　CMS收集器"></a>3.5.6　CMS收集器</h2><p>&emsp;&emsp;CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p>
<p>&emsp;&emsp;从名字（包含”Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p>
<ul>
<li>初始标记（CMS initial mark）</li>
<li>并发标记（CMS concurrent mark）</li>
<li>重新标记（CMS remark）</li>
<li>并发清除（CMS concurrent sweep）</li>
</ul>
<p>&emsp;&emsp;其中，初始标记、重新标记这两个步骤仍然需要”Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>
<p>&emsp;&emsp;由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。通过图3-10可以比较清楚地看到CMS收集器的运作步骤中并发和需要停顿的时间。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05150953_JGmA.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;CMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，Sun公司的一些官方文档中也称之为并发低停顿收集器（Concurrent Low Pause Collector）。但是CMS还远达不到完美的程度，它有以下3个明显的缺点：</p>
<p>&emsp;&emsp;CMS收集器对CPU资源非常敏感。其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，也就是速度下降没有那么明显。实践证明，增量时的CMS收集器效果很一般，在目前版本中，i-CMS已经被声明为”deprecated”，即不再提倡用户使用。</p>
<p>&emsp;&emsp;CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK 1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK 1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CM SInitiatingOccupancyFraction设置得太高很容易导致大量”Concurrent Mode Failure”失败，性能反而降低。</p>
<p>&emsp;&emsp;还有最后一个缺点，在本节开头说过，CMS是一款基于“标记—清除”算法实现的收集器，如果读者对前面这种算法介绍还有印象的话，就可能想到这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。</p>
<h2 id="3-5-7-G1收集器"><a href="#3-5-7-G1收集器" class="headerlink" title="3.5.7　G1收集器"></a>3.5.7　G1收集器</h2><p>&emsp;&emsp;G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，早在JDK 1.7刚刚确立项目目标，Sun公司给出的JDK 1.7 RoadMap里面，它就被视为JDK 1.7中HotSpot虚拟机的一个重要进化特征。从JDK 6u14中开始就有Early Access版本的G1收集器供开发人员实验、试用，由此开始G1收集器的”Experimental”状态持续了数年时间，直至JDK 7u4，Sun公司才认为它达到足够成熟的商用程度，移除了”Experimental”的标识。</p>
<p>&emsp;&emsp;G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。与其他GC收集器相比，G1具备如下特点。</p>
<p>&emsp;&emsp;并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</p>
<p>&emsp;&emsp;分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p>
<p>&emsp;&emsp;空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</p>
<p>&emsp;&emsp;可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
<p>&emsp;&emsp;在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>
<p>&emsp;&emsp;G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p>
<p>&emsp;&emsp;G1把内存“化整为零”的思路，理解起来似乎很容易，但其中的实现细节却远远没有想象中那样简单，否则也不会从2004年Sun实验室发表第一篇G1的论文开始直到今天（将近10年时间）才开发出G1的商用版。笔者以一个细节为例：把Java堆分为多个Region后，垃圾收集是否就真的能以Region为单位进行了？听起来顺理成章，再仔细想想就很容易发现问题所在：Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被本Region中的其他对象引用，而是可以与整个Java堆任意的对象发生引用关系。那在做可达性判定确定对象是否存活的时候，岂不是还得扫描整个Java堆才能保证准确性？这个问题其实并非在G1中才有，只是在G1中更加突出而已。在以前的分代收集中，新生代的规模一般都比老年代要小许多，新生代的收集也比老年代要频繁许多，那回收新生代中的对象时也面临相同的问题，如果回收新生代时也不得不同时扫描老年代的话，那么Minor GC的效率可能下降不少。</p>
<p>&emsp;&emsp;在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。</p>
<p>&emsp;&emsp;如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
<p>&emsp;&emsp;对CMS收集器运作过程熟悉的读者，一定已经发现G1的前几个步骤的运作过程和CMS有很多相似之处。初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，这阶段耗时较长，但可与用户程序并发执行。而最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，从Sun公司透露出来的信息来看，这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。通过图3-11可以比较清楚地看到G1收集器的运作步骤中并发和需要停顿的阶段。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05151228_aT16.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;由于目前G1成熟版本的发布时间还很短，G1收集器几乎可以说还没有经过实际应用的考验，网络上关于G1收集器的性能测试也非常贫乏，到目前为止，笔者还没有搜索到有关的生产环境下的性能测试报告。强调“生产环境下的测试报告”是因为对于垃圾收集器来说，仅仅通过简单的Java代码写个Microbenchmark程序来创建、移除Java对象，再用-XX:+PrintGCDetails等参数来查看GC日志是很难做到准确衡量其性能的。因此，关于G1收集器的性能部分，笔者引用了Sun实验室的论文《Garbage-First Garbage Collection》中的一段测试数据。</p>
<p>&emsp;&emsp;Sun给出的Benchmark的执行硬件为Sun V880服务器（8×750MHz UltraSPARC III CPU、32G内存、Solaris 10操作系统）。执行软件有两个，分别为SPECjbb（模拟商业数据库应用，堆中存活对象约为165MB，结果反映吐量和最长事务处理时间）和telco（模拟电话应答服务应用，堆中存活对象约为100MB，结果反映系统能支持的最大吞吐量）。为了便于对比，还收集了一组使用ParNew+CMS收集器的测试数据。所有测试都配置为与CPU数量相同的8条GC线程。</p>
<p>&emsp;&emsp;在反应停顿时间的软实时目标（Soft Real-Time Goal）测试中，横向是两个测试软件的时间片段配置，单位是毫秒，以（X/Y）的形式表示，代表在Y毫秒内最大允许GC时间为X毫秒（对于CMS收集器，无法直接指定这个目标，通过调整分代大小的方式大致模拟）。纵向是两个软件在对应配置和不同的Java堆容量下的测试结果，V%、avgV%和wV%分别代表的含义如下。</p>
<p>&emsp;&emsp;V%：表示测试过程中，软实时目标失败的概率，软实时目标失败即某个时间片段中实际GC时间超过了允许的最大GC时间。</p>
<p>&emsp;&emsp;avgV%：表示在所有实际GC时间超标的时间片段里，实际GC时间超过最大GC时间的平均百分比（实际GC时间减去允许最大GC时间，再除以总时间片段）。</p>
<p>&emsp;&emsp;wV%：表示在测试结果最差的时间片段里，实际GC时间占用执行时间的百分比。</p>
<p>&emsp;&emsp;测试结果见表3-1。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05151402_I45h.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;从表3-1所示的结果可见，对于telco来说，软实时目标失败的概率控制在0.5%～0.7%之间，SPECjbb就要差一些，但也控制在2%～5%之间，概率随着（X/Y）的比值减小而增加。另一方面，失败时超出允许GC时间的比值随着总时间片段增加而变小（分母变大了），在（100/200）、512MB的配置下，G1收集器出现了某些时间片段下100%时间在进行GC的最坏情况。而相比之下，CMS收集器的测试结果就要差很多，3种Java堆容量下都出现了100%时间进行GC的情况。</p>
<p>&emsp;&emsp;在吞吐量测试中，测试数据取3次SPECjbb和15次telco的平均结果如图3-12所示。在SPECjbb的应用下，各种配置下的G1收集器表现出了一致的行为，吞吐量看起来只与允许最大GC时间成正比关系，而在telco的应用中，不同配置对吞吐量的影响则显得很微弱。与CMS收集器的吞吐量对比可以看到，在SPECjbb测试中，在堆容量超过768MB时，CMS收集器有5%～10%的优势，而在telco测试中，CMS的优势则要小一些，只有3%～4%左右。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05151452_Q1vN.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;在更大规模的生产环境下，笔者引用一段在StackOverflow.com上看到的经验与读者分享：“我在一个真实的、较大规模的应用程序中使用过G1：大约分配有60～70GB内存，存活对象大约在20～50GB之间。服务器运行Linux操作系统，JDK版本为6u22。G1与PS/PS Old相比，最大的好处是停顿时间更加可控、可预测，如果我在PS中设置一个很低的最大允许GC时间，譬如期望50毫秒内完成GC（-XX:MaxGCPauseMillis=50），但在65GB的Java堆下有可能得到的直接结果是一次长达30秒至2分钟的漫长的Stop-The-World过程；而G1与CMS相比，虽然它们都立足于低停顿时间，CMS仍然是我现在的选择，但是随着Oracle对G1的持续改进，我相信G1会是最终的胜利者。如果你现在采用的收集器没有出现问题，那就没有任何理由现在去选择G1，如果你的应用追求低停顿，那G1现在已经可以作为一个可尝试的选择，如果你的应用追求吞吐量，那G1并不会为你带来什么特别的好处”。</p>
<h2 id="3-5-8-理解GC日志"><a href="#3-5-8-理解GC日志" class="headerlink" title="3.5.8　理解GC日志"></a>3.5.8　理解GC日志</h2><p>&emsp;&emsp;阅读GC日志是处理Java虚拟机内存问题的基础技能，它只是一些人为确定的规则，没有太多技术含量。在本书的第1版中没有专门讲解如何阅读分析GC日志，为此作者收到许多读者来信，反映对此感到困惑，因此专门增加本节内容来讲解如何理解GC日志。</p>
<p>&emsp;&emsp;每一种收集器的日志形式都是由它们自身的实现所决定的，换而言之，每个收集器的日志格式都可以不一样。但虚拟机设计者为了方便用户阅读，将各个收集器的日志都维持一定的共性，例如以下两段典型的GC日志：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">33.125</span>:[GC[DefNew:<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">3712</span>K），<span class="number">0.0025925</span> secs]<span class="number">3324</span>K-＞<span class="number">152</span>K（<span class="number">11904</span>K），<span class="number">0.0031680</span> secs]</div><div class="line"><span class="number">100.667</span>:[Full GC[Tenured:<span class="number">0</span> K-＞<span class="number">210</span>K（<span class="number">10240</span>K），<span class="number">0.0149142</span>secs]<span class="number">4603</span>K-＞<span class="number">210</span>K（<span class="number">19456</span>K），[Perm:<span class="number">2999</span>K-＞<span class="number">2999</span>K（<span class="number">21248</span>K）]，<span class="number">0.0150007</span> secs][Times:user=<span class="number">0.01</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p>
<p>&emsp;&emsp;GC日志开头的”[GC”和”[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有”Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现”[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示”[Full GC（System）”。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[Full GC <span class="number">283.736</span>:[ParNew:<span class="number">261599</span>K-＞<span class="number">261599</span>K（<span class="number">261952</span>K），<span class="number">0.0000288</span> secs]</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;接下来的”[DefNew”、”[Tenured”、”[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的，例如上面样例所使用的Serial收集器中的新生代名为”Default New Generation”，所以显示的是”[DefNew”。如果是ParNew收集器，新生代名称就会变为”[ParNew”，意为”Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为”PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。</p>
<p>&emsp;&emsp;后面方括号内部的”3324K-＞152K（3712K）”含义是“GC前该内存区域已使用容量-＞GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的”3324K-＞152K（11904K）”表示“GC前Java堆已使用容量-＞GC后Java堆已使用容量（Java堆总容量）”。</p>
<p>&emsp;&emsp;再往后，”0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如”[Times:user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致，分别代表用户态消耗的CPU时间、内核态消耗的CPU事件和操作从开始到结束所经过的墙钟时间（Wall Clock Time）。CPU时间与墙钟时间的区别是，墙钟时间包括各种非运算的等待耗时，例如等待磁盘I/O、等待线程阻塞，而CPU时间不包括这些耗时，但当系统有多CPU或者多核的话，多线程操作会叠加这些CPU时间，所以读者看到user或sys时间超过real时间是完全正常的。</p>
<h2 id="3-5-9-垃圾收集器参数总结"><a href="#3-5-9-垃圾收集器参数总结" class="headerlink" title="3.5.9　垃圾收集器参数总结"></a>3.5.9　垃圾收集器参数总结</h2><p>&emsp;&emsp;JDK 1.7中的各种垃圾收集器到此已全部介绍完毕，在描述过程中提到了很多虚拟机非稳定的运行参数，在表3-2中整理了这些参数供读者实践时参考。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05151728_8LFi.png" alt="输入图片说明" title="在这里输入图片标题"><br><img src="https://static.oschina.net/uploads/img/201704/05151758_I3YN.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h1 id="3-6-内存分配与回收策略"><a href="#3-6-内存分配与回收策略" class="headerlink" title="3.6　内存分配与回收策略"></a>3.6　内存分配与回收策略</h1><p>&emsp;&emsp;Java技术体系中所提倡的自动内存管理最终可以归结为自动化地解决了两个问题：给对象分配内存以及回收分配给对象的内存。关于回收内存这一点，我们已经使用了大量篇幅去介绍虚拟机中的垃圾收集器体系以及运作原理，现在我们再一起来探讨一下给对象分配内存的那点事儿。</p>
<p>&emsp;&emsp;对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配[1]），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p>
<p>&emsp;&emsp;接下来我们将会讲解几条最普遍的内存分配规则，并通过代码去验证这些规则。本节下面的代码在测试时使用Client模式虚拟机运行，没有手工指定收集器组合，换句话说，验证的是在使用Serial/Serial Old收集器下（ParNew/Serial Old收集器组合的规则也基本一致）的内存分配和回收的策略。读者不妨根据自己项目中使用的收集器写一些程序去验证一下使用其他几种收集器的内存分配策略。</p>
<h2 id="3-6-1-对象优先在Eden分配"><a href="#3-6-1-对象优先在Eden分配" class="headerlink" title="3.6.1　对象优先在Eden分配"></a>3.6.1　对象优先在Eden分配</h2><p>&emsp;&emsp;大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>&emsp;&emsp;虚拟机提供了-XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。在实际应用中，内存回收日志一般是打印到文件后通过日志工具进行分析，不过本实验的日志并不多，直接阅读就能看得很清楚。</p>
<p>&emsp;&emsp;代码清单3-5的testAllocation()方法中，尝试分配3个2MB大小和1个4MB大小的对象，在运行时通过-Xms20M、-Xmx20M、-Xmn10M这3个参数限制了Java堆大小为20MB，不可扩展，其中10MB分配给新生代，剩下的10MB分配给老年代。-XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8:1，从输出的结果也可以清晰地看到”eden space 8192K、from space 1024K、to space 1024K”的信息，新生代总可用空间为9216KB（Eden区+1个Survivor区的总容量）。</p>
<p>&emsp;&emsp;执行testAllocation()中分配allocation4对象的语句时会发生一次Minor GC，这次GC的结果是新生代6651KB变为148KB，而总内存占用量则几乎没有减少（因为allocation1、allocation2、allocation3三个对象都是存活的，虚拟机几乎没有找到可回收的对象）。这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。</p>
<p>&emsp;&emsp;这次GC结束后，4MB的allocation4对象顺利分配在Eden中，因此程序执行完的结果是Eden占用4MB（被allocation4占用），Survivor空闲，老年代被占用6MB（被allocation1、allocation2、allocation3占用）。通过GC日志可以证实这一点。</p>
<p>&emsp;&emsp;注意　作者多次提到的Minor GC和Full GC有什么不一样吗？</p>
<p>&emsp;&emsp;新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>&emsp;&emsp;老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<p>&emsp;&emsp;代码清单3-5　新生代Minor GC<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>；</div><div class="line"><span class="comment">/**</span></div><div class="line">*VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails</div><div class="line">-XX:SurvivorRatio=8</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">byte</span>[]allocation1，allocation2，allocation3，allocation4；</div><div class="line">allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]；<span class="comment">//出现一次Minor GC</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[GC[DefNew:<span class="number">6651</span>K-＞<span class="number">148</span>K（<span class="number">9216</span>K），<span class="number">0.0070106</span> secs]<span class="number">6651</span>K-＞<span class="number">6292</span>K（<span class="number">19456</span>K），</div><div class="line"><span class="number">0.0070426</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.00</span>，real=<span class="number">0.00</span> secs]</div><div class="line">Heap</div><div class="line">def <span class="keyword">new</span> generation total <span class="number">9216</span>K,used <span class="number">4326</span>K[<span class="number">0x029d0000</span>，<span class="number">0x033d0000</span>，<span class="number">0x033d0000</span>）</div><div class="line">eden space <span class="number">8192</span>K，<span class="number">51</span>%used[<span class="number">0x029d0000</span>，<span class="number">0x02de4828</span>，<span class="number">0x031d0000</span>）</div><div class="line">from space <span class="number">1024</span>K，<span class="number">14</span>%used[<span class="number">0x032d0000</span>，<span class="number">0x032f5370</span>，<span class="number">0x033d0000</span>）</div><div class="line">to space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x031d0000</span>，<span class="number">0x031d0000</span>，<span class="number">0x032d0000</span>）</div><div class="line">tenured generation total <span class="number">10240</span>K,used <span class="number">6144</span>K[<span class="number">0x033d0000</span>，<span class="number">0x03dd0000</span>，<span class="number">0x03dd0000</span>）</div><div class="line">the space <span class="number">10240</span>K，<span class="number">60</span>%used[<span class="number">0x033d0000</span>，<span class="number">0x039d0030</span>，<span class="number">0x039d0200</span>，<span class="number">0x03dd0000</span>）</div><div class="line">compacting perm gen total <span class="number">12288</span>K,used <span class="number">2114</span>K[<span class="number">0x03dd0000</span>，<span class="number">0x049d0000</span>，<span class="number">0x07dd0000</span>）</div><div class="line">the space <span class="number">12288</span>K，<span class="number">17</span>%used[<span class="number">0x03dd0000</span>，<span class="number">0x03fe0998</span>，<span class="number">0x03fe0a00</span>，<span class="number">0x049d0000</span>）</div><div class="line">No shared spaces configured.</div></pre></td></tr></table></figure></p>
<h2 id="3-6-2-大对象直接进入老年代"><a href="#3-6-2-大对象直接进入老年代" class="headerlink" title="3.6.2　大对象直接进入老年代"></a>3.6.2　大对象直接进入老年代</h2><p>&emsp;&emsp;所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<p>&emsp;&emsp;虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（复习一下：新生代采用复制算法收集内存）。</p>
<p>&emsp;&emsp;执行代码清单3-6中的testPretenureSizeThreshold()方法后，我们看到Eden空间几乎没有被使用，而老年代的10MB空间被使用了40%，也就是4MB的allocation对象直接就分配在老年代中，这是因为PretenureSizeThreshold被设置为3MB（就是3145728，这个参数不能像-Xmx之类的参数一样直接写3MB），因此超过3MB的对象都会直接在老年代进行分配。注意　PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效，Parallel Scavenge收集器不认识这个参数，Parallel Scavenge收集器一般并不需要设置。如果遇到必须使用此参数的场合，可以考虑ParNew加CMS的收集器组合。</p>
<p>&emsp;&emsp;代码清单3-6　大对象直接进入老年代<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>；</div><div class="line"><span class="comment">/**</span></div><div class="line">*VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails-XX:SurvivorRatio=8</div><div class="line">*-XX:PretenureSizeThreshold=3145728</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">byte</span>[]allocation；</div><div class="line">allocation=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]；<span class="comment">//直接分配在老年代中</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Heap</div><div class="line">def <span class="keyword">new</span> generation total <span class="number">9216</span>K,used <span class="number">671</span>K[<span class="number">0x029d0000</span>，<span class="number">0x033d0000</span>，<span class="number">0x033d0000</span>）</div><div class="line">eden space <span class="number">8192</span>K，<span class="number">8</span>%used[<span class="number">0x029d0000</span>，<span class="number">0x02a77e98</span>，<span class="number">0x031d0000</span>）</div><div class="line">from space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x031d0000</span>，<span class="number">0x031d0000</span>，<span class="number">0x032d0000</span>）</div><div class="line">to space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x032d0000</span>，<span class="number">0x032d0000</span>，<span class="number">0x033d0000</span>）</div><div class="line">tenured generation total <span class="number">10240</span>K,used <span class="number">4096</span>K[<span class="number">0x033d0000</span>，<span class="number">0x03dd0000</span>，<span class="number">0x03dd0000</span>）</div><div class="line">the space <span class="number">10240</span>K，<span class="number">40</span>%used[<span class="number">0x033d0000</span>，<span class="number">0x037d0010</span>，<span class="number">0x037d0200</span>，<span class="number">0x03dd0000</span>）</div><div class="line">compacting perm gen total <span class="number">12288</span>K,used <span class="number">2107</span>K[<span class="number">0x03dd0000</span>，<span class="number">0x049d0000</span>，<span class="number">0x07dd0000</span>）</div><div class="line">the space <span class="number">12288</span>K，<span class="number">17</span>%used[<span class="number">0x03dd0000</span>，<span class="number">0x03fdefd0</span>，<span class="number">0x03fdf000</span>，<span class="number">0x049d0000</span>）</div><div class="line">No shared spaces configured.</div></pre></td></tr></table></figure></p>
<h2 id="3-6-3-长期存活的对象将进入老年代"><a href="#3-6-3-长期存活的对象将进入老年代" class="headerlink" title="3.6.3　长期存活的对象将进入老年代"></a>3.6.3　长期存活的对象将进入老年代</h2><p>&emsp;&emsp;既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p>
<p>&emsp;&emsp;读者可以试试分别以-XX:MaxTenuringThreshold=1和-XX:MaxTenuringThreshold=15两种设置来执行代码清单3-7中的testTenuringThreshold()方法，此方法中的allocation1对象需要256KB内存，Survivor空间可以容纳。当MaxTenuringThreshold=1时，allocation1对象在第二次GC发生时进入老年代，新生代已使用的内存GC后非常干净地变成0KB。而MaxTenuringThreshold=15时，第二次GC发生后，allocation1对象则还留在新生代Survivor空间，这时新生代仍然有404KB被占用。</p>
<p>&emsp;&emsp;代码清单3-7　长期存活的对象进入老年代<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>；</div><div class="line"><span class="comment">/**</span></div><div class="line">*VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails-XX:SurvivorRatio=8-XX:MaxTenuringThreshold=1</div><div class="line">*-XX:+PrintTenuringDistribution</div><div class="line">*/</div><div class="line"><span class="meta">@SuppressWarnings</span>（<span class="string">"unused"</span>）</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">byte</span>[]allocation1，allocation2，allocation3；</div><div class="line">allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[_1MB/<span class="number">4</span>]；</div><div class="line"><span class="comment">//什么时候进入老年代取决于XX:MaxTenuringThreshold设置</span></div><div class="line">allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]；</div><div class="line">allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]；</div><div class="line">allocation3=<span class="keyword">null</span>；</div><div class="line">allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以MaxTenuringThreshold=1参数来运行的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">[GC[DefNew</div><div class="line">Desired Survivor size <span class="number">524288</span> bytes,<span class="keyword">new</span> threshold <span class="number">1</span>（max <span class="number">1</span>）</div><div class="line">-age <span class="number">1</span>:<span class="number">414664</span> bytes，<span class="number">414664</span> total</div><div class="line">:<span class="number">4859</span>K-＞<span class="number">404</span>K（<span class="number">9216</span>K），<span class="number">0.0065012</span> secs]<span class="number">4859</span>K-＞<span class="number">4500</span>K（<span class="number">19456</span>K），<span class="number">0.0065283</span> secs][Times:user=<span class="number">0.02</span> sys=<span class="number">0.00</span>，real=<span class="number">0.02</span> secs]</div><div class="line">[GC[DefNew</div><div class="line">Desired Survivor size <span class="number">524288</span> bytes,<span class="keyword">new</span> threshold <span class="number">1</span>（max <span class="number">1</span>）</div><div class="line">:<span class="number">4500</span>K-＞<span class="number">0</span>K（<span class="number">9216</span>K），<span class="number">0.0009253</span> secs]<span class="number">8596</span>K-＞<span class="number">4500</span>K（<span class="number">19456</span>K），<span class="number">0.0009458</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.00</span>，real=<span class="number">0.00</span> secs]</div><div class="line">Heap</div><div class="line">def <span class="keyword">new</span> generation total <span class="number">9216</span>K,used <span class="number">4178</span>K[<span class="number">0x029d0000</span>，<span class="number">0x033d0000</span>，<span class="number">0x033d0000</span>）</div><div class="line">eden space <span class="number">8192</span>K，<span class="number">51</span>%used[<span class="number">0x029d0000</span>，<span class="number">0x02de4828</span>，<span class="number">0x031d0000</span>）</div><div class="line">from space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x031d0000</span>，<span class="number">0x031d0000</span>，<span class="number">0x032d0000</span>）</div><div class="line">to space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x032d0000</span>，<span class="number">0x032d0000</span>，<span class="number">0x033d0000</span>）</div><div class="line">tenured generation total <span class="number">10240</span>K,used <span class="number">4500</span>K[<span class="number">0x033d0000</span>，<span class="number">0x03dd0000</span>，<span class="number">0x03dd0000</span>）</div><div class="line">the space <span class="number">10240</span>K，<span class="number">43</span>%used[<span class="number">0x033d0000</span>，<span class="number">0x03835348</span>，<span class="number">0x03835400</span>，<span class="number">0x03dd0000</span>）</div><div class="line">compacting perm gen total <span class="number">12288</span>K,used <span class="number">2114</span>K[<span class="number">0x03dd0000</span>，<span class="number">0x049d0000</span>，<span class="number">0x07dd0000</span>）</div><div class="line">the space <span class="number">12288</span>K，<span class="number">17</span>%used[<span class="number">0x03dd0000</span>，<span class="number">0x03fe0998</span>，<span class="number">0x03fe0a00</span>，<span class="number">0x049d0000</span>）</div><div class="line">No shared spaces configured.</div><div class="line">以MaxTenuringThreshold=<span class="number">15</span>参数来运行的结果：</div><div class="line">[GC[DefNew</div><div class="line">Desired Survivor size <span class="number">524288</span> bytes,<span class="keyword">new</span> threshold <span class="number">15</span>（max <span class="number">15</span>）</div><div class="line">-age <span class="number">1</span>:<span class="number">414664</span> bytes，<span class="number">414664</span> total</div><div class="line">:<span class="number">4859</span>K-＞<span class="number">404</span>K（<span class="number">9216</span>K），<span class="number">0.0049637</span> secs]<span class="number">4859</span>K-＞<span class="number">4500</span>K（<span class="number">19456</span>K），<span class="number">0.0049932</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.00</span>，real=<span class="number">0.00</span> secs]</div><div class="line">[GC[DefNew</div><div class="line">Desired Survivor size <span class="number">524288</span> bytes,<span class="keyword">new</span> threshold <span class="number">15</span>（max <span class="number">15</span>）</div><div class="line">-age <span class="number">2</span>:<span class="number">414520</span> bytes，<span class="number">414520</span> total</div><div class="line">:<span class="number">4500</span>K-＞<span class="number">404</span>K（<span class="number">9216</span>K），<span class="number">0.0008091</span> secs]<span class="number">8596</span>K-＞<span class="number">4500</span>K（<span class="number">19456</span>K），<span class="number">0.0008305</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.00</span>，real=<span class="number">0.00</span> secs]</div><div class="line">Heap</div><div class="line">def <span class="keyword">new</span> generation total <span class="number">9216</span>K,used <span class="number">4582</span>K[<span class="number">0x029d0000</span>，<span class="number">0x033d0000</span>，<span class="number">0x033d0000</span>）</div><div class="line">eden space <span class="number">8192</span>K，<span class="number">51</span>%used[<span class="number">0x029d0000</span>，<span class="number">0x02de4828</span>，<span class="number">0x031d0000</span>）</div><div class="line">from space <span class="number">1024</span>K，<span class="number">39</span>%used[<span class="number">0x031d0000</span>，<span class="number">0x03235338</span>，<span class="number">0x032d0000</span>）</div><div class="line">to space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x032d0000</span>，<span class="number">0x032d0000</span>，<span class="number">0x033d0000</span>）</div><div class="line">tenured generation total <span class="number">10240</span>K,used <span class="number">4096</span>K[<span class="number">0x033d0000</span>，<span class="number">0x03dd0000</span>，<span class="number">0x03dd0000</span>）</div><div class="line">the space <span class="number">10240</span>K，<span class="number">40</span>%used[<span class="number">0x033d0000</span>，<span class="number">0x037d0010</span>，<span class="number">0x037d0200</span>，<span class="number">0x03dd0000</span>）</div><div class="line">compacting perm gen total <span class="number">12288</span>K,used <span class="number">2114</span>K[<span class="number">0x03dd0000</span>，<span class="number">0x049d0000</span>，<span class="number">0x07dd0000</span>）</div><div class="line">the space <span class="number">12288</span>K，<span class="number">17</span>%used[<span class="number">0x03dd0000</span>，<span class="number">0x03fe0998</span>，<span class="number">0x03fe0a00</span>，<span class="number">0x049d0000</span>）</div><div class="line">No shared spaces configured.</div></pre></td></tr></table></figure></p>
<h2 id="3-6-4-动态对象年龄判定"><a href="#3-6-4-动态对象年龄判定" class="headerlink" title="3.6.4　动态对象年龄判定"></a>3.6.4　动态对象年龄判定</h2><p>&emsp;&emsp;为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<p>&emsp;&emsp;执行代码清单3-8中的testTenuringThreshold2()方法，并设置-XX:MaxTenuringThreshold=15，会发现运行结果中Survivor的空间占用仍然为0%，而老年代比预期增加了6%，也就是说，allocation1、allocation2对象都直接进入了老年代，而没有等到15岁的临界年龄。因为这两个对象加起来已经到达了512KB，并且它们是同年的，满足同年对象达到Survivor空间的一半规则。我们只要注释掉其中一个对象new操作，就会发现另外一个就不会晋升到老年代中去了。</p>
<p>&emsp;&emsp;代码清单3-8　动态对象年龄判定<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>；</div><div class="line"><span class="comment">/**</span></div><div class="line">*VM参数：-verbose:gc-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails-XX:SurvivorRatio=8-XX:MaxTenuringThreshold=15</div><div class="line">*-XX:+PrintTenuringDistribution</div><div class="line">*/</div><div class="line"><span class="meta">@SuppressWarnings</span>（<span class="string">"unused"</span>）</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold2</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">byte</span>[]allocation1，allocation2，allocation3，allocation4；</div><div class="line">allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[_1MB/<span class="number">4</span>]；</div><div class="line"><span class="comment">//allocation1+allocation2大于survivo空间一半</span></div><div class="line">allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[_1MB/<span class="number">4</span>]；</div><div class="line">allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]；</div><div class="line">allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]；</div><div class="line">allocation4=<span class="keyword">null</span>；</div><div class="line">allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>*_1MB]；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[GC[DefNew</div><div class="line">Desired Survivor size <span class="number">524288</span> bytes,<span class="keyword">new</span> threshold <span class="number">1</span>（max <span class="number">15</span>）</div><div class="line">-age <span class="number">1</span>:<span class="number">676824</span> bytes，<span class="number">676824</span> total</div><div class="line">:<span class="number">5115</span>K-＞<span class="number">660</span>K（<span class="number">9216</span>K），<span class="number">0.0050136</span> secs]<span class="number">5115</span>K-＞<span class="number">4756</span>K（<span class="number">19456</span>K），<span class="number">0.0050443</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.01</span>，real=<span class="number">0.01</span> secs]</div><div class="line">[GC[DefNew</div><div class="line">Desired Survivor size <span class="number">524288</span> bytes,<span class="keyword">new</span> threshold <span class="number">15</span>（max <span class="number">15</span>）</div><div class="line">:<span class="number">4756</span>K-＞<span class="number">0</span>K（<span class="number">9216</span>K），<span class="number">0.0010571</span> secs]<span class="number">8852</span>K-＞<span class="number">4756</span>K（<span class="number">19456</span>K），<span class="number">0.0011009</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.00</span>，real=<span class="number">0.00</span> secs]</div><div class="line">Heap</div><div class="line">def <span class="keyword">new</span> generation total <span class="number">9216</span>K,used <span class="number">4178</span>K[<span class="number">0x029d0000</span>，<span class="number">0x033d0000</span>，<span class="number">0x033d0000</span>）</div><div class="line">eden space <span class="number">8192</span>K，<span class="number">51</span>%used[<span class="number">0x029d0000</span>，<span class="number">0x02de4828</span>，<span class="number">0x031d0000</span>）</div><div class="line">from space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x031d0000</span>，<span class="number">0x031d0000</span>，<span class="number">0x032d0000</span>）</div><div class="line">to space <span class="number">1024</span>K，<span class="number">0</span>%used[<span class="number">0x032d0000</span>，<span class="number">0x032d0000</span>，<span class="number">0x033d0000</span>）</div><div class="line">tenured generation total <span class="number">10240</span>K,used <span class="number">4756</span>K[<span class="number">0x033d0000</span>，<span class="number">0x03dd0000</span>，<span class="number">0x03dd0000</span>）</div><div class="line">the space <span class="number">10240</span>K，<span class="number">46</span>%used[<span class="number">0x033d0000</span>，<span class="number">0x038753e8</span>，<span class="number">0x03875400</span>，<span class="number">0x03dd0000</span>）</div><div class="line">compacting perm gen total <span class="number">12288</span>K,used <span class="number">2114</span>K[<span class="number">0x03dd0000</span>，<span class="number">0x049d0000</span>，<span class="number">0x07dd0000</span>）</div><div class="line">the space <span class="number">12288</span>K，<span class="number">17</span>%used[<span class="number">0x03dd0000</span>，<span class="number">0x03fe09a0</span>，<span class="number">0x03fe0a00</span>，<span class="number">0x049d0000</span>）</div><div class="line">No shared spaces configured.</div></pre></td></tr></table></figure></p>
<h2 id="3-6-5-空间分配担保"><a href="#3-6-5-空间分配担保" class="headerlink" title="3.6.5　空间分配担保"></a>3.6.5　空间分配担保</h2><p>&emsp;&emsp;在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
<p>&emsp;&emsp;下面解释一下“冒险”是冒了什么风险，前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>
<p>&emsp;&emsp;取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁，参见代码清单3-9，请读者在JDK 6 Update 24之前的版本中运行测试。</p>
<p>&emsp;&emsp;代码清单3-9　空间分配担保<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> int_1MB=<span class="number">1024</span>*<span class="number">1024</span>；</div><div class="line"><span class="comment">/**</span></div><div class="line">*VM参数：-Xms20M-Xmx20M-Xmn10M-XX:+PrintGCDetails-XX:SurvivorRatio=8-XX:-HandlePromotionFailure</div><div class="line">*/</div><div class="line"><span class="meta">@SuppressWarnings</span>（<span class="string">"unused"</span>）</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHandlePromotion</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">byte</span>[]allocation1，allocation2，allocation3，allocation4，allocation5，allocation6，allocation7；</div><div class="line">allocation1=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">allocation2=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">allocation3=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">allocation1=<span class="keyword">null</span>；</div><div class="line">allocation4=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">allocation5=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">allocation6=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">allocation4=<span class="keyword">null</span>；</div><div class="line">allocation5=<span class="keyword">null</span>；</div><div class="line">allocation6=<span class="keyword">null</span>；</div><div class="line">allocation7=<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span>*_1MB]；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以HandlePromotionFailure=false参数来运行的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[GC[DefNew:<span class="number">6651</span>K-＞<span class="number">148</span>K（<span class="number">9216</span>K），<span class="number">0.0078936</span> secs]<span class="number">6651</span>K-＞<span class="number">4244</span>K（<span class="number">19456</span>K），<span class="number">0.0079192</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.02</span>，real=<span class="number">0.02</span> secs]</div><div class="line">[GC[DefNew:<span class="number">6378</span>K-＞<span class="number">6378</span>K（<span class="number">9216</span>K），<span class="number">0.0000206</span>secs][Tenured:<span class="number">4096</span>K-＞<span class="number">4244</span>K（<span class="number">10240</span>K），<span class="number">0.0042901</span> secs]<span class="number">10474</span>K-＞<span class="number">4244</span>K（<span class="number">19456</span>K），[Perm:<span class="number">2104</span>K-＞<span class="number">2104</span>K（<span class="number">12288</span>K）]，<span class="number">0.0043613</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.00</span>，real=<span class="number">0.00</span> secs]</div></pre></td></tr></table></figure></p>
<p>以HandlePromotionFailure=true参数来运行的结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[GC[DefNew:<span class="number">6651</span>K-＞<span class="number">148</span>K（<span class="number">9216</span>K），<span class="number">0.0054913</span> secs]<span class="number">6651</span>K-＞<span class="number">4244</span>K（<span class="number">19456</span>K），<span class="number">0.0055327</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.00</span>，real=<span class="number">0.00</span> secs]</div><div class="line">[GC[DefNew:<span class="number">6378</span>K-＞<span class="number">148</span>K（<span class="number">9216</span>K），<span class="number">0.0006584</span> secs]<span class="number">10474</span>K-＞<span class="number">4244</span>K（<span class="number">19456</span>K），<span class="number">0.0006857</span> secs][Times:user=<span class="number">0.00</span> sys=<span class="number">0.00</span>，real=<span class="number">0.00</span> secs]</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;在JDK 6 Update 24之后，这个测试结果会有差异，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，观察OpenJDK中的源码变化（见代码清单3-10），虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>
<p>&emsp;&emsp;代码清单3-10　HotSpot中空间分配检查的代码片段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">bool TenuredGeneration:promotion_attempt_is_safe（size_t</div><div class="line">max_promotion_in_bytes）<span class="keyword">const</span>&#123;</div><div class="line"><span class="comment">//老年代最大可用的连续空间</span></div><div class="line">size_t available=max_contiguous_available()；</div><div class="line"><span class="comment">//每次晋升到老年代的平均大小</span></div><div class="line">size_t av_promo=（size_t）gc_stats()-＞avg_promoted()-＞padded_average()；</div><div class="line"><span class="comment">//老年代可用空间是否大于平均晋升大小，或者老年代可用空间是否大于当此GC时新生代所有对象容量</span></div><div class="line">bool res=（available＞=av_promo）||（available＞=</div><div class="line">max_promotion_in_bytes）；</div><div class="line"><span class="keyword">return</span> res；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="3-7-本章小结"><a href="#3-7-本章小结" class="headerlink" title="3.7　本章小结"></a>3.7　本章小结</h1><p>&emsp;&emsp;本章介绍了垃圾收集的算法、几款JDK 1.7中提供的垃圾收集器特点以及运作原理。通过代码实例验证了Java虚拟机中自动内存分配及回收的主要规则。</p>
<p>&emsp;&emsp;内存回收与垃圾收集器在很多时候都是影响系统性能、并发能力的主要因素之一，虚拟机之所以提供多种不同的收集器以及提供大量的调节参数，是因为只有根据实际应用需求、实现方式选择最优的收集方式才能获取最高的性能。没有固定收集器、参数组合，也没有最优的调优方法，虚拟机也就没有什么必然的内存回收行为。因此，学习虚拟机内存知识，如果要到实践调优阶段，那么必须了解每个具体收集器的行为、优势和劣势、调节参数。在接下来的两章中，作者将会介绍内存分析的工具和调优的一些具体案例。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/06/6-类文件结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/06/6-类文件结构/" itemprop="url">
                  6. 类文件结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-06T17:34:34+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1　概述"></a>6.1　概述</h1><p>&emsp;&emsp;记得在第一节计算机程序课上我的老师就讲过：“计算机只认识0和1，所以我们写的程序需要经编译器翻译成由0和1构成的二进制格式才能由计算机执行”。10多年时间过去了，今天的计算机仍然只能识别0和1，但由于最近10年内虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p>
<h1 id="6-2-无关性的基石"><a href="#6-2-无关性的基石" class="headerlink" title="6.2　无关性的基石"></a>6.2　无关性的基石</h1><p>&emsp;&emsp;如果计算机的CPU指令集只有x86一种，操作系统也只有Windows一种，那也许Java语言就不会出现。Java在刚刚诞生之时曾经提出过一个非常著名的宣传口号：“一次编写，到处运行（Write Once,Run Anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴求。在无时无刻不充满竞争的IT领域，不可能只有Wintel[1]存在，我们也不希望只有Wintel存在，各种不同的硬件体系结构和不同的操作系统肯定会长期并存发展。“与平台无关”的理想最终实现在操作系统的应用层上：Sun公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。</p>
<p>&emsp;&emsp;各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（ByteCode）是构成平台无关性的基石，但本节标题中刻意省略了“平台”二字，那是因为笔者注意到虚拟机的另外一种中立特性——语言无关性正越来越被开发者所重视。到目前为止，或许大部分程序员都还认为Java虚拟机执行Java程序是一件理所当然和天经地义的事情。但在Java发展之初，设计者就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，他们在发布规范文档的时候，也刻意把Java的规范拆分成了Java语言规范《The Java Language Specification》及Java虚拟机规范《The Java Virtual Machine Specification》。并且在1997年发布的第一版Java虚拟机规范中就曾经承诺过：”In the future,we will consider bounded extensions to the Java virtual machine to provide better support for other languages”（在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于JVM之上），当Java虚拟机发展到JDK 1.7～1.8的时候，JVM设计者通过JSR-292基本兑现了这个承诺。</p>
<p>&emsp;&emsp;时至今日，商业机构和开源机构已经在Java语言之外发展出一大批在Java虚拟机之上运行的语言，如Clojure、Groovy、JRuby、Jython、Scala等。使用过这些语言的开发者可能还不是非常多，但是听说过的人肯定已经不少，随着时间的推移，谁能保证日后Java虚拟机在语言无关性上的优势不会赶上甚至超越它在平台无关性上的优势呢？</p>
<p>&emsp;&emsp;实现语言无关性的基础仍然是虚拟机和字节码存储格式。Java虚拟机不和包括Java在内的任何语言绑定，它只与“Class文件”这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言，如图6-1所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/05173512_rHaC.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。因此，有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。</p>
<h1 id="6-3-Class类文件的结构"><a href="#6-3-Class类文件的结构" class="headerlink" title="6.3　Class类文件的结构"></a>6.3　Class类文件的结构</h1><p>&emsp;&emsp;解析Class文件的数据结构是本章的最主要内容。笔者曾经在前言中阐述过本书的写作风格：力求在保证逻辑准确的前提下，用尽量通俗的语言和案例去讲述虚拟机中与开发关系最为密切的内容。但是，对数据结构方面的讲解不可避免地会比较枯燥，而这部分内容又是了解虚拟机的重要基础之一。如果想比较深入地了解虚拟机，那么这部分是不能不接触的。</p>
<p>&emsp;&emsp;在本章关于Class文件结构的讲解中，我们将以《Java虚拟机规范（第2版）》（1999年发布，对应于JDK 1.4时代的Java虚拟机）中的定义为主线，这部分内容虽然古老，但它所包含的指令、属性是Class文件中最重要和最基础的。同时，我们也会以后续JDK 1.5～JDK 1.7中添加的内容为支线进行较为简略的、介绍性的讲解，如果读者对这部分内容特别感兴趣，建议参考笔者所翻译的《Java虚拟机规范（Java SE 7）》中文版，可以在笔者的网站（ <a href="http://icyfenix.iteye.com/" target="_blank" rel="external">http://icyfenix.iteye.com/</a> ）上下载到这本书的全文PDF。</p>
<p>&emsp;&emsp;注意　任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。本章中，笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它并不一定以磁盘文件的形式存在。</p>
<p>&emsp;&emsp;Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前[1]的方式分割成若干个8位字节进行存储。</p>
<p>&emsp;&emsp;根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。</p>
<p>&emsp;&emsp;无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
<p>&emsp;&emsp;表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以”_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由表6-1所示的数据项构成。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06154542_yXkn.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。</p>
<p>&emsp;&emsp;本节结束之前，笔者需要再重复讲一下，Class的结构不像XML等描述语言，由于它没有任何分隔符号，所以在表6-1中的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering,Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。接下来我们将一起看看这个表中各个数据项的具体含义。</p>
<h2 id="6-3-1-魔数与Class文件的版本"><a href="#6-3-1-魔数与Class文件的版本" class="headerlink" title="6.3.1　魔数与Class文件的版本"></a>6.3.1　魔数与Class文件的版本</h2><p>&emsp;&emsp;每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式，如gif或者jpeg等在文件头中都存有魔数。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过同时又不会引起混淆即可。Class文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝？），这个魔数值在Java还称做”Oak”语言的时候（大约是1991年前后）就已经确定下来了。它还有一段很有趣的历史，据Java开发小组最初的关键成员Patrick Naughton所说：“我们一直在寻找一些好玩的、容易记忆的东西，选择0xCAFEBABE是因为它象征着著名咖啡品牌Peet’s Coffee中深受欢迎的Baristas咖啡”，这个魔数似乎也预示着日后”Java”这个商标名称的出现。</p>
<p>&emsp;&emsp;紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
<p>&emsp;&emsp;例如，JDK 1.1能支持版本号为45.0～45.65535的Class文件，无法执行版本号为46.0以上的Class文件，而JDK 1.2则能支持45.0～46.65535的Class文件。现在，最新的JDK版本为1.7，可生成的Class文件主版本号最大值为51.0。</p>
<p>&emsp;&emsp;为了讲解方便，笔者准备了一段最简单的Java代码（见代码清单6-1），本章后面的内容都将以这段小程序使用JDK 1.6编译输出的Class文件为基础来进行讲解。</p>
<p>&emsp;&emsp;代码清单6-1　简单的Java代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.fenixsoft.clazz;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> m;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> m + <span class="number">1</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;图6-2显示的是使用十六进制编辑器WinHex打开这个Class文件的结果，可以清楚地看见开头4个字节的十六进制表示是0xCAFEBABE，代表次版本号的第5个和第6个字节值为0x0000，而主版本号的值为0x0032，也即是十进制的50，该版本号说明这个文件是可以被JDK 1.6或以上版本虚拟机执行的Class文件。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06154750_bxf4.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;表6-2列出了从JDK 1.1到JDK 1.7，主流JDK版本编译器输出的默认和可支持的Class文件版本号。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06154841_NjqZ.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h2 id="6-3-2-常量池"><a href="#6-3-2-常量池" class="headerlink" title="6.3.2　常量池"></a>6.3.2　常量池</h2><p>&emsp;&emsp;紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</p>
<p>&emsp;&emsp;由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的，如图6-3所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就代表常量池中有21项常量，索引值范围为1～21。在Class文件格式规范制定之时，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06154935_gBOP.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>&emsp;&emsp;Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是在虚拟机加载Class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态连接的内容，在下一章介绍虚拟机类加载过程时再进行详细讲解。</p>
<p>&emsp;&emsp;常量池中每一项常量都是一个表，在JDK 1.7之前共有11种结构各不相同的表结构数据，在JDK 1.7中为了更好地支持动态语言调用，又额外增加了3种（CONSTANT_MethodHandle_info、CONSTANT_MethodType_info和CONSTANT_InvokeDynamic_info，本章不会涉及这3种新增的类型，在第8章介绍字节码执行和方法调用时，将会详细讲解）。</p>
<p>&emsp;&emsp;这14种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag，取值见表6-3中标志列），代表当前这个常量属于哪种常量类型。这14种常量类型所代表的具体含义见表6-3。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06155102_mBLM.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;之所以说常量池是最烦琐的数据，是因为这14种常量类型各自均有自己的结构。回头看看图6-3中常量池的第一项常量，它的标志位（偏移地址：0x0000000A）是0x07，查表6-3的标志列发现这个常量属于CONSTANT_Class_info类型，此类型的常量代表一个类或者接口的符号引用。CONSTANT_Class_info的结构比较简单，见表6-4。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06162057_DGRN.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;tag是标志位，上面已经讲过了，它用于区分常量类型；name_index是一个索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名，这里name_index值（偏移地址：0x0000000B）为0x0002，也即是指向了常量池中的第二项常量。继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个CONSTANT_Utf8_info类型的常量。CONSTANT_Utf8_info类型的结构见表6-5。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06162146_2Sy3.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。UTF-8缩略编码与普通UTF-8编码的区别是：从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</p>
<p>&emsp;&emsp;顺便提一下，由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以CONSTANT_Utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。</p>
<p>&emsp;&emsp;本例中这个字符串的length值（偏移地址：0x0000000E）为0x001D，也就是长29字节，往后29字节正好都在1～127的ASCII码范围以内，内容为”org/fenixsoft/clazz/TestClass”，有兴趣的读者可以自己逐个字节换算一下，换算结果如图6-4选中的部分所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06162307_B9x2.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;到此为止，我们分析了TestClass.class常量池中21个常量中的两个，其余的19个常量都可以通过类似的方法计算出来。为了避免计算过程占用过多的版面，后续的19个常量的计算过程可以借助计算机来帮我们完成。在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap，代码清单6-2中列出了使用javap工具的-verbose参数输出的TestClass.class文件字节码内容（此清单中省略了常量池以外的信息）。前面我们曾经提到过，Class文件中还有很多数据项都要引用常量池中的常量，所以代码清单6-2中的内容在后续的讲解过程中还要经常使用到。</p>
<p>&emsp;&emsp;代码清单6-2　使用Javap命令输出常量表<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">C:\＞javap-verbose TestClass</div><div class="line">Compiled from"TestClass.java"</div><div class="line">public class org.fenixsoft.clazz.TestClass extends java.lang.Object</div><div class="line">SourceFile:"TestClass.java"</div><div class="line">minor version:0</div><div class="line">major version:50</div><div class="line">Constant pool:</div><div class="line">const#1=class#2；//org/fenixsoft/clazz/TestClass</div><div class="line">const#2=Asciz org/fenixsoft/clazz/TestClass；</div><div class="line">const#3=class#4；//java/lang/Object</div><div class="line">const#4=Asciz java/lang/Object；</div><div class="line">const#5=Asciz m；</div><div class="line">const#6=Asciz I；</div><div class="line">const#7=Asciz＜init＞；</div><div class="line">const#8=Asciz()V；</div><div class="line">const#9=Asciz Code；</div><div class="line">const#10=Method#3.#11；//java/lang/Object."＜init＞":()V</div><div class="line">const#11=NameAndType#7:#8；//"＜init＞":()V</div><div class="line">const#12=Asciz LineNumberTable；</div><div class="line">const#13=Asciz LocalVariableTable；</div><div class="line">const#14=Asciz this；</div><div class="line">const#15=Asciz Lorg/fenixsoft/clazz/TestClass；</div><div class="line">const#16=Asciz inc；</div><div class="line">const#17=Asciz()I；</div><div class="line">const#18=Field#1.#19；//org/fenixsoft/clazz/TestClass.m:I</div><div class="line">const#19=NameAndType#5:#6；//m:I</div><div class="line">const#20=Asciz SourceFile；</div><div class="line">const#21=Asciz TestClass.java；</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;从代码清单6-2中可以看出，计算机已经帮我们把整个常量池的21项常量都计算了出来，并且第1、2项常量的计算结果与我们手工计算的结果一致。仔细看一下会发现，其中有一些常量似乎从来没有在代码中出现过，如”I”、”V”、”＜init＞”、”LineNumberTable”、”LocalVariableTable”等，这些看起来在代码任何一处都没有出现过的常量是哪里来的呢？</p>
<p>&emsp;&emsp;这部分自动生成的常量的确没有在Java代码里面直接出现过，但它们会被后面即将讲到的字段表（field_info）、方法表（method_info）、属性表（attribute_info）引用到，它们会用来描述一些不方便使用“固定字节”进行表达的内容。譬如描述方法的返回值是什么？有几个参数？每个参数的类型是什么？因为Java中的“类”是无穷无尽的，无法通过简单的无符号字节来描述一个方法用到了什么类，因此在描述方法的这些信息时，需要引用常量表中的符号引用进行表达。这部分内容将在后面进一步阐述。最后，笔者将这14种常量项的结构定义总结为表6-6以供读者参考。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06162534_9C7X.png" alt="输入图片说明" title="在这里输入图片标题"><br><img src="https://static.oschina.net/uploads/img/201704/06162616_JmNc.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h2 id="6-3-3-访问标志"><a href="#6-3-3-访问标志" class="headerlink" title="6.3.3　访问标志"></a>6.3.3　访问标志</h2><p>&emsp;&emsp;在常量池结束之后，紧接着的两个字节代表访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。具体的标志位以及标志的含义见表6-7。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06162717_AKEm.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;access_flags中一共有16个标志位可以使用，当前只定义了其中8个[1]，没有使用到的标志位要求一律为0。以代码清单6-1中的代码为例，TestClass是一个普通Java类，不是接口、枚举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK 1.2之后的编译器进行编译，因此它的ACC_PUBLIC、ACC_SUPER标志应当为真，而ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM这6个标志应当为假，因此它的access_flags的值应为：0x0001|0x0020=0x0021。从图6-5中可以看出，access_flags标志（偏移地址：0x000000EF）的确为0x0021。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06162801_OPEN.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<h2 id="6-3-4-类索引、父类索引与接口索引集合"><a href="#6-3-4-类索引、父类索引与接口索引集合" class="headerlink" title="6.3.4　类索引、父类索引与接口索引集合"></a>6.3.4　类索引、父类索引与接口索引集合</h2><p>&emsp;&emsp;类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p>
<p>&emsp;&emsp;类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。图6-6演示了代码清单6-1的代码的类索引查找过程。</p>
<p>&emsp;&emsp;对于接口索引集合，入口的第一项——u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。代码清单6-1中的代码的类索引、父类索引与接口表索引的内容如图6-7所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06162858_oRxX.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;从偏移地址0x000000F1开始的3个u2类型的值分别为0x0001、0x0003、0x0000，也就是类索引为1，父类索引为3，接口索引集合大小为0，查询前面代码清单6-2中javap命令计算出来的常量池，找出对应的类和父类的常量，结果如代码清单6-3所示。</p>
<p>&emsp;&emsp;代码清单6-3　部分常量池内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">const#1=class#2；//org/fenixsoft/clazz/TestClass</div><div class="line">const#2=Asciz org/fenixsoft/clazz/TestClass；</div><div class="line">const#3=class#4；//java/lang/Object</div><div class="line">const#4=Asciz java/lang/Object；</div></pre></td></tr></table></figure></p>
<h2 id="6-3-5-字段表集合"><a href="#6-3-5-字段表集合" class="headerlink" title="6.3.5　字段表集合"></a>6.3.5　字段表集合</h2><p>&emsp;&emsp;字段表（field_info）用于描述接口或者类中声明的变量。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。我们可以想一想在Java中描述一个字段可以包含什么信息？可以包括的信息有：字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。表6-8中列出了字段表的最终格式。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06163036_pP1W.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义见表6-9。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06163115_ATP4.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;很明显，在实际情况中，ACC_PUBLIC、ACC_PRIVATE、ACC_PROTECTED三个标志最多只能选择其一，ACC_FINAL、ACC_VOLATILE不能同时选择。接口之中的字段必须有ACC_PUBLIC、ACC_STATIC、ACC_FINAL标志，这些都是由Java本身的语言规则所决定的。</p>
<p>&emsp;&emsp;跟随access_flags标志的是两项索引值：name_index和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。现在需要解释一下“简单名称”、“描述符”以及前面出现过多次的“全限定名”这三种特殊字符串的概念。</p>
<p>&emsp;&emsp;全限定名和简单名称很好理解，以代码清单6-1中的代码为例，”org/fenixsoft/clazz/TestClass”是这个类的全限定名，仅仅是把类全名中的“.”替换成了“/”而已，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“；”表示全限定名结束。简单名称是指没有类型和参数修饰的方法或者字段名称，这个类中的inc()方法和m字段的简单名称分别是”inc”和”m”。</p>
<p>&emsp;&emsp;相对于全限定名和简单名称来说，方法和字段的描述符就要复杂一些。描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示，详见表6-10。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06163216_kRui.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为”java.lang.String[][]”类型的二维数组，将被记录为：”[[Ljava/lang/String；”，一个整型数组”int[]”将被记录为”[I”。</p>
<p>&emsp;&emsp;用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法void inc()的描述符为”()V”，方法java.lang.String toString()的描述符为”()Ljava/lang/String；”，方法int indexOf（char[]source,int sourceOffset,int sourceCount,char[]target,int targetOffset,int targetCount,int fromIndex）的描述符为”（[CII[CIII）I”。</p>
<p>&emsp;&emsp;对于代码清单6-1中的TestClass.class文件来说，字段表集合从地址0x000000F8开始，第一个u2类型的数据为容量计数器fields_count，如图6-8所示，其值为0x0001，说明这个类只有一个字段表数据。接下来紧跟着容量计数器的是access_flags标志，值为0x0002，代表private修饰符的ACC_PRIVATE标志位为真（ACC_PRIVATE标志的值为0x0002），其他修饰符为假。代表字段名称的name_index的值为0x0005，从代码清单6-2列出的常量表中可查得第5项常量是一个CONSTANT_Utf8_info类型的字符串，其值为”m”，代表字段描述符的descriptor_index的值为0x0006，指向常量池的字符串”I”，根据这些信息，我们可以推断出原代码定义的字段为：”private int m；”。</p>
<p>&emsp;&emsp;字段表都包含的固定数据项目到descriptor_index为止就结束了，不过在descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。对于本例中的字段m，它的属性表计数器为0，也就是没有需要额外描述的信息，但是，如果将字段m的声明改为”final static int m=123；”，那就可能会存在一项名称为ConstantValue的属性，其值指向常量123。关于attribute_info的其他内容，将在6.3.7节介绍属性表的数据项目时再进一步讲解。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06163306_dCSQ.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</p>
<h2 id="6-3-6-方法表集合"><a href="#6-3-6-方法表集合" class="headerlink" title="6.3.6　方法表集合"></a>6.3.6　方法表集合</h2><p>&emsp;&emsp;如果理解了上一节关于字段表的内容，那本节关于方法表的内容将会变得很简单。Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项，见表6-11。这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06163416_q2wP.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。对于方法表，所有标志位及其取值可参见表6-12。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06163454_8ke6.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;行文至此，也许有的读者会产生疑问，方法的定义可以通过访问标志、名称索引、描述符索引表达清楚，但方法里面的代码去哪里了？方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为”Code”的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目，将在6.3.7节中详细讲解。</p>
<p>&emsp;&emsp;我们继续以代码清单6-1中的Class文件为例对方法表集合进行分析，如图6-9所示，方法表集合的入口地址为：0x00000101，第一个u2类型的数据（即是计数器容量）的值为0x0002，代表集合中有两个方法（这两个方法为编译器添加的实例构造器＜init＞和源码中的方法inc()）。第一个方法的访问标志值为0x001，也就是只有ACC_PUBLIC标志为真，名称索引值为0x0007，查代码清单6-2的常量池得方法名为”＜init＞”，描述符索引值为0x0008，对应常量为”()V”，属性表计数器attributes_count的值为0x0001就表示此方法的属性表集合有一项属性，属性名称索引为0x0009，对应常量为”Code”，说明此属性是方法的字节码描述。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06163537_wyy6.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;与字段表集合相对应的，如果父类方法在子类中没有被重写（Override），方法表集合中就不会出现来自父类的方法信息。但同样的，有可能会出现由编译器自动添加的方法，最典型的便是类构造器”＜clinit＞”方法和实例构造器”＜init＞”[1]方法。</p>
<p>&emsp;&emsp;在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名[2]，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的。</p>
<h2 id="6-3-7-属性表集合"><a href="#6-3-7-属性表集合" class="headerlink" title="6.3.7　属性表集合"></a>6.3.7　属性表集合</h2><p>&emsp;&emsp;属性表（attribute_info）在前面的讲解之中已经出现过数次，在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</p>
<p>&emsp;&emsp;与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。为了能正确解析Class文件，《Java虚拟机规范（第2版）》中预定义了9项虚拟机实现应当能识别的属性，而在最新的《Java虚拟机规范（Java SE 7）》版中，预定义属性已经增加到21项，具体内容见表6-13。下文中将对其中一些属性中的关键常用的部分进行讲解。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06163653_a8z7.png" alt="输入图片说明" title="在这里输入图片标题"><br><img src="https://static.oschina.net/uploads/img/201704/06163727_bpk9.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足表6-14中所定义的结构。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06163818_jdP7.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;1.Code属性</p>
<p>&emsp;&emsp;Java程序方法体中的代码经过Javac编译器处理后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如表6-15所示。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06165326_ZKMW.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，常量值固定为”Code”，它代表了该属性的属性名称，attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。</p>
<p>&emsp;&emsp;max_stack代表了操作数栈（Operand Stacks）深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配栈帧（Stack Frame）中的操作栈深度。</p>
<p>&emsp;&emsp;max_locals代表了局部变量表所需的存储空间。在这里，max_locals的单位是Slot,Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。方法参数（包括实例方法中的隐藏参数”this”）、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放。另外，并不是在方法中用到了多少个局部变量，就把这些局部变量所占Slot之和作为max_locals的值，原因是局部变量表中的Slot可以重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的Slot可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配Slot给各个变量使用，然后计算出max_locals的大小。</p>
<p>&emsp;&emsp;code_length和code用来存储Java源程序编译后生成的字节码指令。code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那么每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及参数应当如何理解。我们知道一个u1数据类型的取值范围为0x00～0xFF，对应十进制的0～255，也就是一共可以表达256条指令，目前，Java虚拟机规范已经定义了其中约200条编码值对应的指令含义，编码与指令之间的对应关系可查阅本书的附录B“虚拟机字节码指令表”。</p>
<p>&emsp;&emsp;关于code_length，有一件值得注意的事情，虽然它是一个u4类型的长度值，理论上最大值可以达到232-1，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器也会拒绝编译。一般来讲，编写Java代码时只要不是刻意去编写一个超长的方法来为难编译器，是不太可能超过这个最大值的限制。但是，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就可能因为方法生成字节码超长的原因而导致编译失败。</p>
<p>&emsp;&emsp;Code属性是Class文件中最重要的一个属性，如果把一个Java程序中的信息分为代码（Code，方法体里面的Java代码）和元数据（Metadata，包括类、字段、方法定义及其他信息）两部分，那么在整个Class文件中，Code属性用于描述代码，所有的其他数据项目都用于描述元数据。了解Code属性是学习后面关于字节码执行引擎内容的必要基础，能直接阅读字节码也是工作中分析Java代码语义问题的必要工具和基本技能，因此笔者准备了一个比较详细的实例来讲解虚拟机是如何使用这个属性的。</p>
<p>&emsp;&emsp;继续以代码清单6-1的TestClass.class文件为例，如图6-10所示，这是上一节分析过的实例构造器”＜init＞”方法的Code属性。它的操作数栈的最大深度和本地变量表的容量都为0x0001，字节码区域所占空间的长度为0x0005。虚拟机读取到字节码区域的长度后，按照顺序依次读入紧随的5个字节，并根据字节码指令表翻译出所对应的字节码指令。翻译”2A B7 00 0A B1”的过程为：</p>
<ol>
<li>读入2A，查表得0x2A对应的指令为aload_0，这个指令的含义是将第0个Slot中为reference类型的本地变量推送到操作数栈顶。</li>
<li>读入B7，查表得0xB7对应的指令为invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，调用此对象的实例构造器方法、private方法或者它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪一个方法，它指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的方法符号引用。</li>
<li>读入00 0A，这是invokespecial的参数，查常量池得0x000A对应的常量为实例构造器”＜init＞”方法的符号引用。</li>
<li>读入B1，查表得0xB1对应的指令为return，含义是返回此方法，并且返回值为void。这条指令执行后，当前方法结束。</li>
</ol>
<p><img src="https://static.oschina.net/uploads/img/201704/06165530_D5GQ.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;这段字节码虽然很短，但是至少可以看出它的执行过程中的数据交换、方法调用等操作都是基于栈（操作栈）的。我们可以初步猜测：Java虚拟机执行字节码是基于栈的体系结构。但是与一般基于堆栈的零字节指令又不太一样，某些指令（如invokespecial）后面还会带有参数，关于虚拟机字节码执行的讲解是后面两章的重点，我们不妨把这里的疑问放到第8章去解决。</p>
<p>&emsp;&emsp;我们再次使用javap命令把此Class文件中的另外一个方法的字节码指令也计算出来，结果如代码清单6-4所示。</p>
<p>&emsp;&emsp;代码清单6-4　用javap命令计算字节码指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//原始Java代码</div><div class="line">public class TestClass &#123;</div><div class="line">    private int m；</div><div class="line"></div><div class="line">    public int inc() &#123;</div><div class="line">        return m + 1；</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">C:\＞javap-verbose TestClass</div><div class="line">//常量表部分的输出见代码清单6-1，因版面原因这里省略掉</div><div class="line">&#123;</div><div class="line">public org.fenixsoft.clazz.TestClass()；</div><div class="line">        Code:</div><div class="line">        Stack=1，Locals=1，Args_size=1</div><div class="line">        0:aload_0</div><div class="line">        1:invokespecial#10；//Method java/lang/Object.&quot;＜init＞&quot;:()V</div><div class="line">        4:return</div><div class="line">        LineNumberTable:</div><div class="line">        line 3:0</div><div class="line">        LocalVariableTable:</div><div class="line">        Start Length Slot Name Signature</div><div class="line">        0 5 0this Lorg/fenixsoft/clazz/TestClass；</div><div class="line">public int inc();</div><div class="line">        Code:</div><div class="line">        Stack=2，Locals=1，Args_size=1</div><div class="line">        0:aload_0</div><div class="line">        1:getfield#18；//Field m:I</div><div class="line">        4:iconst_1</div><div class="line">        5:iadd</div><div class="line">        6:ireturn</div><div class="line">        LineNumberTable:</div><div class="line">        line 8:0</div><div class="line">        LocalVariableTable:</div><div class="line">        Start Length Slot Name Signature</div><div class="line">        0 7 0this Lorg/fenixsoft/clazz/TestClass；</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;如果大家注意到javap中输出的”Args_size”的值，可能会有疑问：这个类有两个方法——实例构造器＜init＞()和inc()，这两个方法很明显都是没有参数的，为什么Args_size会为1？而且无论是在参数列表里还是方法体内，都没有定义任何局部变量，那Locals又为什么会等于1？如果有这样的疑问，大家可能是忽略了一点：在任何实例方法里面，都可以通过”this”关键字访问到此方法所属的对象。这个访问机制对Java程序的编写很重要，而它的实现却非常简单，仅仅是通过Javac编译器编译的时候把对this关键字的访问转变为对一个普通方法参数的访问，然后在虚拟机调用实例方法时自动传入此参数而已。因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量，局部变量表中也会预留出第一个Slot位来存放对象实例的引用，方法参数值从1开始计算。这个处理只对实例方法有效，如果代码清单6-1中的inc()方法声明为static，那Args_size就不会等于1而是等于0了。</p>
<p>&emsp;&emsp;在字节码指令之后的是这个方法的显式异常处理表（下文简称异常表）集合，异常表对于Code属性来说并不是必须存在的，如代码清单6-4中就没有异常表生成。</p>
<p>&emsp;&emsp;异常表的格式如表6-16所示，它包含4个字段，这些字段的含义为：如果当字节码在第start_pc行[1]到第end_pc行之间（不含第end_pc行）出现了类型为catch_type或者其子类的异常（catch_type为指向一个CONSTANT_Class_info型常量的索引），则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转向到handler_pc处进行处理。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06165841_2J7X.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;异常表实际上是Java代码的一部分，编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制[2]。</p>
<p>&emsp;&emsp;代码清单6-5是一段演示异常表如何运作的例子，这段代码主要演示了在字节码层面中try-catch-finally是如何实现的。在阅读字节码之前，大家不妨先看看下面的Java源码，想一下这段代码的返回值在出现异常和不出现异常的情况下分别应该是多少？</p>
<p>&emsp;&emsp;代码清单6-5　异常表运作演示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">//Java源码</div><div class="line">    public int inc() &#123;</div><div class="line">        int x;</div><div class="line">        try &#123;</div><div class="line">            x = 1;</div><div class="line">            return x;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            x = 2;</div><div class="line">            return x;</div><div class="line">        &#125; finally &#123;</div><div class="line">            x = 3;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">//编译后的ByteCode字节码及异常表</div><div class="line">public int inc()；</div><div class="line">Code:</div><div class="line">Stack=1，Locals=5，Args_size=1</div><div class="line">0:iconst_1//try块中的x=1</div><div class="line">1:istore_1</div><div class="line">2:iload_1//保存x到returnValue中，此时x=1</div><div class="line">3:istore 4</div><div class="line">5:iconst_3//finaly块中的x=3</div><div class="line">6:istore_1</div><div class="line">7:iload 4//将returnValue中的值放到栈顶，准备给ireturn返回</div><div class="line">9:ireturn</div><div class="line">10:astore_2//给catch中定义的Exception e赋值，存储在Slot 2中</div><div class="line">11:iconst_2//catch块中的x=2</div><div class="line">12:istore_1</div><div class="line">13:iload_1//保存x到returnValue中，此时x=2</div><div class="line">14:istore 4</div><div class="line">16:iconst_3//finaly块中的x=3</div><div class="line">17:istore_1</div><div class="line">18:iload 4//将returnValue中的值放到栈顶，准备给ireturn返回</div><div class="line">20:ireturn</div><div class="line">21:astore_3//如果出现了不属于java.lang.Exception及其子类的异常才会走到这里</div><div class="line">22:iconst_3//finaly块中的x=3</div><div class="line">23:istore_1</div><div class="line">24:aload_3//将异常放置到栈顶，并抛出</div><div class="line">25:athrow</div><div class="line">Exception table:</div><div class="line">from to target type</div><div class="line">0 5 10 Class java/lang/Exception</div><div class="line">0 5 21 any</div><div class="line">10 16 21 any</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;编译器为这段Java源码生成了3条异常表记录，对应3条可能出现的代码执行路径。从Java代码的语义上讲，这3条执行路径分别为：</p>
<ul>
<li>如果try语句块中出现属于Exception或其子类的异常，则转到catch语句块处理。</li>
<li>如果try语句块中出现不属于Exception或其子类的异常，则转到finally语句块处理。</li>
<li>如果catch语句块中出现任何异常，则转到finally语句块处理。</li>
</ul>
<p>&emsp;&emsp;返回到我们上面提出的问题，这段代码的返回值应该是多少？对Java语言熟悉的读者应该很容易说出答案：如果没有出现异常，返回值是1；如果出现了Exception异常，返回值是2；如果出现了Exception以外的异常，方法非正常退出，没有返回值。我们一起来分析一下字节码的执行过程，从字节码的层面上看看为何会有这样的返回结果。</p>
<p>&emsp;&emsp;字节码中第0～4行所做的操作就是将整数1赋值给变量x，并且将此时x的值复制一份副本到最后一个本地变量表的Slot中（这个Slot里面的值在ireturn指令执行前将会被重新读到操作栈顶，作为方法返回值使用。为了讲解方便，笔者给这个Slot起了个名字：returnValue）。如果这时没有出现异常，则会继续走到第5～9行，将变量x赋值为3，然后将之前保存在returnValue中的整数1读入到操作栈顶，最后ireturn指令会以int形式返回操作栈顶中的值，方法结束。如果出现了异常，PC寄存器指针转到第10行，第10～20行所做的事情是将2赋值给变量x，然后将变量x此时的值赋给returnValue，最后再将变量x的值改为3。方法返回前同样将returnValue中保留的整数2读到了操作栈顶。从第21行开始的代码，作用是变量x的值赋为3，并将栈顶的异常抛出，方法结束。</p>
<p>&emsp;&emsp;尽管大家都知道这段代码出现异常的概率非常小，但并不影响它为我们演示异常表的作用。如果大家到这里仍然对字节码的运作过程比较模糊，其实也不要紧，关于虚拟机执行字节码的过程，本书第8章中将会有更详细的讲解。</p>
<p>&emsp;&emsp;2.Exceptions属性</p>
<p>&emsp;&emsp;这里的Exceptions属性是在方法表中与Code属性平级的一项属性，读者不要与前面刚刚讲解完的异常表产生混淆。Exceptions属性的作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。它的结构见表6-17。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06170210_X6A4.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;Exceptions属性中的number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每一种受查异常使用一个exception_index_table项表示，exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p>
<p>&emsp;&emsp;3.LineNumberTable属性</p>
<p>&emsp;&emsp;LineNumberTable属性用于描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g:none或-g:lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。LineNumberTable属性的结构见表6-18。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06170301_eKQG.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;line_number_table是一个数量为line_number_table_length、类型为line_number_info的集合，line_number_info表包括了start_pc和line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。</p>
<p>&emsp;&emsp;4.LocalVariableTable属性</p>
<p>&emsp;&emsp;LocalVariableTable属性用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g:none或-g:vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。LocalVariableTable属性的结构见表6-19。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06170352_r1yu.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;其中，local_variable_info项目代表了一个栈帧与源码中的局部变量的关联，结构见表6-20。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06170429_Clzc.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;start_pc和length属性分别代表了这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。</p>
<p>&emsp;&emsp;name_index和descriptor_index都是指向常量池中CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。</p>
<p>&emsp;&emsp;index是这个局部变量在栈帧局部变量表中Slot的位置。当这个变量数据类型是64位类型时（double和long），它占用的Slot为index和index+1两个。</p>
<p>&emsp;&emsp;顺便提一下，在JDK 1.5引入泛型之后，LocalVariableTable属性增加了一个“姐妹属性”：LocalVariableTypeTable，这个新增的属性结构与LocalVariableTable非常相似，仅仅是把记录的字段描述符的descriptor_index替换成了字段的特征签名（Signature），对于非泛型类型来说，描述符和特征签名能描述的信息是基本一致的，但是泛型引入之后，由于描述符中泛型的参数化类型被擦除掉[3]，描述符就不能准确地描述泛型类型了，因此出现了LocalVariableTypeTable。</p>
<p>&emsp;&emsp;5.SourceFile属性</p>
<p>&emsp;&emsp;SourceFile属性用于记录生成这个Class文件的源码文件名称。这个属性也是可选的，可以分别使用Javac的-g:none或-g:source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性，其结构见表6-21。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06170527_kSjT.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;sourcefile_index数据项是指向常量池中CONSTANT_Utf8_info型常量的索引，常量值是源码文件的文件名。</p>
<p>&emsp;&emsp;6.ConstantValue属性</p>
<p>&emsp;&emsp;ConstantValue属性的作用是通知虚拟机自动为静态变量赋值。只有被static关键字修饰的变量（类变量）才可以使用这项属性。类似”int x=123”和”static int x=123”这样的变量定义在Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非static类型的变量（也就是实例变量）的赋值是在实例构造器＜init＞方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器＜clinit＞方法中或者使用ConstantValue属性。目前Sun Javac编译器的选择是：如果同时使用final和static来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化，如果这个变量没有被final修饰，或者并非基本类型及字符串，则将会选择在＜clinit＞方法中进行初始化。</p>
<p>&emsp;&emsp;虽然有final关键字才更符合”ConstantValue”的语义，但虚拟机规范中并没有强制要求字段必须设置了ACC_FINAL标志，只要求了有ConstantValue属性的字段必须设置ACC_STATIC标志而已，对final关键字的要求是Javac编译器自己加入的限制。而对ConstantValue的属性值只能限于基本类型和String，不过笔者不认为这是什么限制，因为此属性的属性值只是一个常量池的索引号，由于Class文件格式的常量类型中只有与基本属性和字符串相对应的字面量，所以就算ConstantValue属性想支持别的类型也无能为力。ConstantValue属性的结构见表6-22。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06170714_MYOT.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;从数据结构中可以看出，ConstantValue属性是一个定长属性，它的attribute_length数据项值必须固定为2。constantvalue_index数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_Integer_info、CONSTANT_String_info常量中的一种。</p>
<p>&emsp;&emsp;7.InnerClasses属性</p>
<p>&emsp;&emsp;InnerClasses属性用于记录内部类与宿主类之间的关联。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。该属性的结构见表6-23。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06170753_lr26.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一个inner_classes_info表进行描述。inner_classes_info表的结构见表6-24。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06171005_hDlc.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;inner_class_info_index和outer_class_info_index都是指向常量池中CONSTANT_Class_info型常量的索引，分别代表了内部类和宿主类的符号引用。</p>
<p>&emsp;&emsp;inner_name_index是指向常量池中CONSTANT_Utf8_info型常量的索引，代表这个内部类的名称，如果是匿名内部类，那么这项值为0。</p>
<p>&emsp;&emsp;inner_class_access_flags是内部类的访问标志，类似于类的access_flags，它的取值范围见表6-25。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06171051_cuMW.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;8.Deprecated及Synthetic属性</p>
<p>&emsp;&emsp;Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。</p>
<p>&emsp;&emsp;Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为不再推荐使用，它可以通过在代码中使用@deprecated注释进行设置。</p>
<p>&emsp;&emsp;Synthetic属性代表此字段或者方法并不是由Java源码直接产生的，而是由编译器自行添加的，在JDK 1.5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位，其中最典型的例子就是Bridge Method。所有由非用户代码产生的类、方法及字段都应当至少设置Synthetic属性和ACC_SYNTHETIC标志位中的一项，唯一的例外是实例构造器”＜init＞”方法和类构造器”＜clinit＞”方法。</p>
<p>&emsp;&emsp;Deprecated和Synthetic属性的结构非常简单，见表6-26。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06171149_nVtE.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;其中attribute_length数据项的值必须为0x00000000，因为没有任何属性值需要设置。</p>
<p>&emsp;&emsp;9.StackMapTable属性</p>
<p>&emsp;&emsp;StackMapTable属性在JDK 1.6发布后增加到了Class文件规范中，它是一个复杂的变长属性，位于Code属性的属性表中。这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用（见7.3.2节），目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。</p>
<p>&emsp;&emsp;这个类型检查验证器最初来源于Sheng Liang（听名字似乎是虚拟机团队中的华裔成员）为Java ME CLDC实现的字节码验证器。新的验证器在同样能保证Class文件合法性的前提下，省略了在运行期通过数据流分析去确认字节码的行为逻辑合法性的步骤，而是在编译阶段将一系列的验证类型（Verification Types）直接记录在Class文件之中，通过检查这些验证类型代替了类型推导过程，从而大幅提升了字节码验证的性能。这个验证器在JDK 1.6中首次提供，并在JDK 1.7中强制代替原本基于类型推断的字节码验证器。关于这个验证器的工作原理，《Java虚拟机规范（JavaSE 7版）》花费了整整120页的篇幅来讲解描述，并且分析证明新验证方法的严谨性，笔者在此不再赘述。</p>
<p>&emsp;&emsp;StackMapTable属性中包含零至多个栈映射帧（Stack Map Frames），每个栈映射帧都显式或隐式地代表了一个字节码偏移量，用于表示该执行到该字节码时局部变量表和操作数栈的验证类型。类型检查验证器会通过检查目标方法的局部变量和操作数栈所需要的类型来确定一段字节码指令是否符合逻辑约束。StackMapTable属性的结构见表6-27。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06171248_XBCf.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;《Java虚拟机规范（Java SE 7版）》明确规定：在版本号大于或等于50.0的Class文件中，如果方法的Code属性中没有附带StackMapTable属性，那就意味着它带有一个隐式的StackMap属性。这个StackMap属性的作用等同于number_of_entries值为0的StackMapTable属性。一个方法的Code属性最多只能有一个StackMapTable属性，否则将抛出ClassFormatError异常。</p>
<p>&emsp;&emsp;10.Signature属性</p>
<p>&emsp;&emsp;Signature属性在JDK 1.5发布后增加到了Class文件规范之中，它是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。在JDK 1.5中大幅增强了Java语言的语法，在此之后，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去记录泛型类型，是因为Java语言的泛型采用的是擦除法实现的伪泛型，在字节码（Code属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如运行期做反射时无法获得到泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取泛型类型，最终的数据来源也就是这个属性。关于Java泛型、Signature属性和类型擦除，在第10章介绍编译器优化的时候会通过一个具体的例子来讲解。Signature属性的结构见表6-28。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06171341_brv8.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;其中signature_index项的值必须是一个对常量池的有效索引。常量池在该索引处的项必须是CONSTANT_Utf8_info结构，表示类签名、方法类型签名或字段类型签名。如果当前的Signature属性是类文件的属性，则这个结构表示类签名，如果当前的Signature属性是方法表的属性，则这个结构表示方法类型签名，如果当前Signature属性是字段表的属性，则这个结构表示字段类型签名。</p>
<p>&emsp;&emsp;11.BootstrapMethods属性</p>
<p>&emsp;&emsp;BootstrapMethods属性在JDK 1.7发布后增加到了Class文件规范之中，它是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。《Java虚拟机规范（Java SE 7版）》规定，如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件的属性表中必须存在一个明确的BootstrapMethods属性，另外，即使CONSTANT_InvokeDynamic_info类型的常量在常量池中出现过多次，类文件的属性表中最多也只能有一个BootstrapMethods属性。BootstrapMethods属性与JSR-292中的InvokeDynamic指令和java.lang.Invoke包关系非常密切，要介绍这个属性的作用，必须先弄清楚InovkeDynamic指令的运作原理，笔者将在第8章专门用1节篇幅去介绍它们，在此先暂时略过。</p>
<p>&emsp;&emsp;目前的Javac暂时无法生成InvokeDynamic指令和BootstrapMethods属性，必须通过一些非常规的手段才能使用到它们，也许在不久的将来，等JSR-292更加成熟一些，这种状况就会改变。BootstrapMethods属性的结构见表6-29。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06171440_PL7M.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;其中引用到的bootstrap_method结构见表6-30。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06171512_2e9K.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;BootstrapMethods属性中，num_bootstrap_methods项的值给出了bootstrap_methods[]数组中的引导方法限定符的数量。而bootstrap_methods[]数组的每个成员包含了一个指向常量池CONSTANT_MethodHandle结构的索引值，它代表了一个引导方法，还包含了这个引导方法静态参数的序列（可能为空）。bootstrap_methods[]数组中的每个成员必须包含以下3项内容。</p>
<p>&emsp;&emsp;bootstrap_method_ref:bootstrap_method_ref项的值必须是一个对常量池的有效索引。常量池在该索引处的值必须是一个CONSTANT_MethodHandle_info结构。</p>
<p>&emsp;&emsp;num_bootstrap_arguments:num_bootstrap_arguments项的值给出了bootstrap_arguments[]数组成员的数量。</p>
<p>&emsp;&emsp;bootstrap_arguments[]：bootstrap_arguments[]数组的每个成员必须是一个对常量池的有效索引。常量池在该索引处必须是下列结构之一：CONSTANT_String_info、CONSTANT_Class_info、CONSTANT_Integer_info、CONSTANT_Long_info、CONSTANT_Float_info、CONSTANT_Double_info、CONSTANT_MethodHandle_info或CONSTANT_MethodType_info。</p>
<h1 id="6-4-字节码指令简介"><a href="#6-4-字节码指令简介" class="headerlink" title="6.4　字节码指令简介"></a>6.4　字节码指令简介</h1><p>&emsp;&emsp;Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数（称为操作数，Operands）而构成。由于Java虚拟机采用面向操作数栈而不是寄存器的架构（这两种架构的区别和影响将在第8章中探讨），所以大多数的指令都不包含操作数，只有一个操作码。</p>
<p>&emsp;&emsp;字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构，由于限制了Java虚拟机操作码的长度为一个字节（即0～255），这意味着指令集的操作码总数不可能超过256条；又由于Class文件格式放弃了编译后代码的操作数长度对齐，这就意味着虚拟机处理那些超过一个字节数据的时候，不得不在运行时从字节中重建出具体数据的结构，如果要将一个16位长度的无符号整数使用两个无符号字节存储起来（将它们命名为byte1和byte2），那它们的值应该是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">（byte1＜＜8）|byte2</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种操作在某种程度上会导致解释执行字节码时损失一些性能。但这样做的优势也非常明显，放弃了操作数长度对齐[1]，就意味着可以省略很多填充和间隔符号；用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码。这种追求尽可能小数据量、高传输效率的设计是由Java语言设计之初面向网络、智能家电的技术背景所决定的，并一直沿用至今。</p>
<p>&emsp;&emsp;如果不考虑异常处理的话，那么Java虚拟机的解释器可以使用下面这个伪代码当做最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效地工作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">do&#123;</div><div class="line">自动计算PC寄存器的值加1；</div><div class="line">根据PC寄存器的指示位置，从字节码流中取出操作码；</div><div class="line">if（字节码存在操作数）从字节码流中取出操作数；</div><div class="line">执行操作码所定义的操作；</div><div class="line">&#125;while（字节码流长度＞0）；</div></pre></td></tr></table></figure></p>
<h2 id="6-4-1-字节码与数据类型"><a href="#6-4-1-字节码与数据类型" class="headerlink" title="6.4.1　字节码与数据类型"></a>6.4.1　字节码与数据类型</h2><p>&emsp;&emsp;在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如，iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p>
<p>&emsp;&emsp;对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，l代表long,s代表short,b代表byte,c代表char,f代表float,d代表double,a代表reference。也有一些指令的助记符中没有明确地指明操作类型的字母，如arraylength指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。还有另外一些指令，如无条件跳转指令goto则是与数据类型无关的。</p>
<p>&emsp;&emsp;由于Java虚拟机的操作码长度只有一个字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那指令的数量恐怕就会超出一个字节所能表示的数量范围了。因此，Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会故意被设计成非完全独立的（Java虚拟机规范中把这种特性称为”Not Orthogonal”，即并非每种数据类型和每一种操作都有对应的指令）。有一些单独的指令可以在必要的时候用来将一些不支持的类型转换为可被支持的类型。</p>
<p>&emsp;&emsp;表6-31列举了Java虚拟机所支持的与数据类型相关的字节码指令，通过使用数据类型列所代表的特殊字符替换opcode列的指令模板中的T，就可以得到一个具体的字节码指令。如果在表中指令模板与数据类型两列共同确定的格为空，则说明虚拟机不支持对这种数据类型执行这项操作。例如，load指令有操作int类型的iload，但是没有操作byte类型的同类指令。</p>
<p>&emsp;&emsp;注意，从表6-31中可以看出，大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型（Computational Type）。</p>
<p><img src="https://static.oschina.net/uploads/img/201704/06171750_QF0i.png" alt="输入图片说明" title="在这里输入图片标题"><br><img src="https://static.oschina.net/uploads/img/201704/06171823_YEK4.png" alt="输入图片说明" title="在这里输入图片标题"></p>
<p>&emsp;&emsp;在本章中，受篇幅所限，无法对字节码指令集中每条指令进行逐一讲解，但阅读字节码作为了解Java虚拟机的基础技能，是一项应当熟练掌握的能力。笔者将字节码操作按用途大致分为9类，按照分类来为读者概略介绍一下这些指令的用法。如果读者需要了解更详细的信息，可以参考阅读笔者翻译的《Java虚拟机规范（Java SE 7版）》的第6章。</p>
<h2 id="6-4-2-加载和存储指令"><a href="#6-4-2-加载和存储指令" class="headerlink" title="6.4.2　加载和存储指令"></a>6.4.2　加载和存储指令</h2><p>&emsp;&emsp;加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见第2章关于内存区域的介绍）之间来回传输，这类指令包括如下内容。</p>
<p>&emsp;&emsp;将一个局部变量加载到操作栈：iload、iload<em>＜n＞、lload、lload</em>＜n＞、fload、fload<em>＜n＞、dload、dload</em>＜n＞、aload、aload_＜n＞。</p>
<p>&emsp;&emsp;将一个数值从操作数栈存储到局部变量表：istore、istore<em>＜n＞、lstore、lstore</em>＜n＞、fstore、fstore<em>＜n＞、dstore、dstore</em>＜n＞、astore、astore_＜n＞。</p>
<p>&emsp;&emsp;将一个常量加载到操作数栈：bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst<em>m1、iconst</em>＜i＞、lconst<em>＜l＞、fconst</em>＜f＞、dconst_＜d＞。</p>
<p>&emsp;&emsp;扩充局部变量表的访问索引的指令：wide。</p>
<p>&emsp;&emsp;存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p>
<p>&emsp;&emsp;上面所列举的指令助记符中，有一部分是以尖括号结尾的（例如iload<em>＜n＞），这些指令助记符实际上是代表了一组指令（例如iload</em>＜n＞，它代表了iload_0、iload_1、iload_2和iload_3这几条指令）。这几组指令都是某个带有一个操作数的通用指令（例如iload）的特殊形式，对于这若干组特殊指令来说，它们省略掉了显式的操作数，不需要进行取操作数的动作，实际上操作数就隐含在指令中。除了这点之外，它们的语义与原生的通用指令完全一致（例如iload_0的语义与操作数为0时的iload指令语义完全一致）。这种指令表示方法在本书以及《Java虚拟机规范》中都是通用的。</p>
<h2 id="6-4-3-运算指令"><a href="#6-4-3-运算指令" class="headerlink" title="6.4.3　运算指令"></a>6.4.3　运算指令</h2><p>&emsp;&emsp;运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。大体上算术指令可以分为两种：对整型数据进行运算的指令与对浮点型数据进行运算的指令，无论是哪种算术指令，都使用Java虚拟机的数据类型，由于没有直接支持byte、short、char和boolean类型的算术指令，对于这类数据的运算，应使用操作int类型的指令代替。整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现，所有的算术指令如下:</p>
<ul>
<li>加法指令：iadd、ladd、fadd、dadd。</li>
<li>减法指令：isub、lsub、fsub、dsub。</li>
<li>乘法指令：imul、lmul、fmul、dmul。</li>
<li>除法指令：idiv、ldiv、fdiv、ddiv。</li>
<li>求余指令：irem、lrem、frem、drem。</li>
<li>取反指令：ineg、lneg、fneg、dneg。</li>
<li>位移指令：ishl、ishr、iushr、lshl、lshr、lushr。</li>
<li>按位或指令：ior、lor。</li>
<li>按位与指令：iand、land。</li>
<li>按位异或指令：ixor、lxor。</li>
<li>局部变量自增指令：iinc。</li>
<li>比较指令：dcmpg、dcmpl、fcmpg、fcmpl、lcmp。</li>
</ul>
<p>&emsp;&emsp;Java虚拟机的指令集直接支持了在《Java语言规范》中描述的各种对整数及浮点数操作（参见《Java语言规范（第3版）》中的4.2.2节和4.2.4节）的语义。数据运算可能会导致溢出，例如两个很大的正整数相加，结果可能会是一个负数，这种数学上不可能出现的溢出现象，对于程序员来说是很容易理解的，但其实Java虚拟机规范没有明确定义过整型数据溢出的具体运算结果，仅规定了在处理整型数据时，只有除法指令（idiv和ldiv）以及求余指令（irem和lrem）中当出现除数为零时会导致虚拟机抛出ArithmeticException异常，其余任何整型数运算场景都不应该抛出运行时异常。</p>
<p>&emsp;&emsp;Java虚拟机规范要求虚拟机实现在处理浮点数时，必须严格遵循IEEE 754规范中所规定的行为和限制。也就是说，Java虚拟机必须完全支持IEEE 754中定义的非正规浮点数值（Denormalized Floating-Point Numbers）和逐级下溢（Gradual Underflow）的运算规则。这些特征将会使某些数值算法处理起来变得相对容易一些。</p>
<p>&emsp;&emsp;Java虚拟机要求在进行浮点数运算时，所有的运算结果都必须舍入到适当的精度，非精确的结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的。这种舍入模式也是IEEE 754规范中的默认舍入模式，称为向最接近数舍入模式。</p>
<p>&emsp;&emsp;在把浮点数转换为整数时，Java虚拟机使用IEEE 754标准中的向零舍入模式，这种模式的舍入结果会导致数字被截断，所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。</p>
<p>&emsp;&emsp;另外，Java虚拟机在处理浮点数运算时，不会抛出任何运行时异常（这里所讲的是Java语言中的异常，请读者勿与IEEE 754规范中的浮点异常互相混淆，IEEE 754的浮点异常是一种运算信号），当一个操作产生溢出时，将会使用有符号的无穷大来表示，如果某个操作结果没有明确的数学定义的话，将会使用NaN值来表示。所有使用NaN值作为操作数的算术操作，结果都会返回NaN。</p>
<p>&emsp;&emsp;在对long类型数值进行比较时，虚拟机采用带符号的比较方式，而对浮点数值进行比较时（dcmpg、dcmpl、fcmpg、fcmpl），虚拟机会采用IEEE 754规范所定义的无信号比较（Nonsignaling Comparisons）方式。</p>
<h2 id="6-4-4-类型转换指令"><a href="#6-4-4-类型转换指令" class="headerlink" title="6.4.4　类型转换指令"></a>6.4.4　类型转换指令</h2><p>&emsp;&emsp;类型转换指令可以将两种不同的数值类型进行相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。</p>
<p>&emsp;&emsp;Java虚拟机直接支持（即转换时无需显式的转换指令）以下数值类型的宽化类型转换（Widening Numeric Conversions，即小范围类型向大范围类型的安全转换）：</p>
<ul>
<li>int类型到long、float或者double类型。</li>
<li>long类型到float、double类型。</li>
<li>float类型到double类型。</li>
</ul>
<p>&emsp;&emsp;相对的，处理窄化类型转换（Narrowing Numeric Conversions）时，必须显式地使用转换指令来完成，这些转换指令包括：i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。</p>
<p>&emsp;&emsp;在将int或long类型窄化转换为整数类型T的时候，转换过程仅仅是简单地丢弃除最低位N个字节以外的内容，N是类型T的数据类型长度，这将可能导致转换结果与输入值有不同的正负号。这点很容易理解，因为原来符号位处于数值的最高位，高位被丢弃之后，转换结果的符号就取决于低N个字节的首位了。</p>
<p>&emsp;&emsp;在将一个浮点值窄化转换为整数类型T（T限于int或long类型之一）的时候，将遵循以下转换规则：</p>
<ul>
<li>如果浮点值是NaN，那转换结果就是int或long类型的0。</li>
<li>如果浮点值不是无穷大的话，浮点值使用IEEE 754的向零舍入模式取整，获得整数值v，如果v在目标类型T（int或long）的表示范围之内，那转换结果就是v。</li>
<li>否则，将根据v的符号，转换为T所能表示的最大或者最小正数。</li>
</ul>
<p>&emsp;&emsp;从double类型到float类型的窄化转换过程与IEEE 754中定义的一致，通过IEEE 754向最接近数舍入模式舍入得到一个可以使用float类型表示的数字。如果转换结果的绝对值太小而无法使用float来表示的话，将返回float类型的正负零。如果转换结果的绝对值太大而无法使用float来表示的话，将返回float类型的正负无穷大，对于double类型的NaN值将按规定转换为float类型的NaN值。</p>
<p>&emsp;&emsp;尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。</p>
<h2 id="6-4-5-对象创建与访问指令"><a href="#6-4-5-对象创建与访问指令" class="headerlink" title="6.4.5　对象创建与访问指令"></a>6.4.5　对象创建与访问指令</h2><p>&emsp;&emsp;虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令（在第7章会讲到数组和普通类的类型创建过程是不同的）。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，这些指令如下：</p>
<ul>
<li>创建类实例的指令：new。</li>
<li>创建数组的指令：newarray、anewarray、multianewarray。</li>
<li>访问类字段（static字段，或者称为类变量）和实例字段（非static字段，或者称为实例变量）的指令：getfield、putfield、getstatic、putstatic。</li>
<li>把一个数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload。</li>
<li>将一个操作数栈的值存储到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore。</li>
<li>取数组长度的指令：arraylength。</li>
<li>检查类实例类型的指令：instanceof、checkcast。</li>
</ul>
<h2 id="6-4-6-操作数栈管理指令"><a href="#6-4-6-操作数栈管理指令" class="headerlink" title="6.4.6　操作数栈管理指令"></a>6.4.6　操作数栈管理指令</h2><p>&emsp;&emsp;如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令，包括：</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈：pop、pop2。</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2。</li>
<li>将栈最顶端的两个数值互换：swap。</li>
</ul>
<h2 id="6-4-7-控制转移指令"><a href="#6-4-7-控制转移指令" class="headerlink" title="6.4.7　控制转移指令"></a>6.4.7　控制转移指令</h2><p>&emsp;&emsp;控制转移指令可以让Java虚拟机有条件或无条件地从指定的位置指令而不是控制转移指令的下一条指令继续执行程序，从概念模型上理解，可以认为控制转移指令就是在有条件或无条件地修改PC寄存器的值。控制转移指令如下：</p>
<ul>
<li>条件分支：ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。</li>
<li>复合条件分支：tableswitch、lookupswitch。</li>
<li>无条件分支：goto、goto_w、jsr、jsr_w、ret。</li>
</ul>
<p>&emsp;&emsp;在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作，为了可以无须明显标识一个实体值是否null，也有专门的指令用来检测null值。</p>
<p>&emsp;&emsp;与前面算术运算时的规则一致，对于boolean类型、byte类型、char类型和short类型的条件分支比较操作，都是使用int类型的比较指令来完成，而对于long类型、float类型和double类型的条件分支比较操作，则会先执行相应类型的比较运算指令（dcmpg、dcmpl、fcmpg、fcmpl、lcmp，见6.4.3节），运算指令会返回一个整型值到操作数栈中，随后再执行int类型的条件分支比较操作来完成整个分支跳转。由于各种类型的比较最终都会转化为int类型的比较操作，int类型比较是否方便完善就显得尤为重要，所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p>
<h2 id="6-4-8-方法调用和返回指令"><a href="#6-4-8-方法调用和返回指令" class="headerlink" title="6.4.8　方法调用和返回指令"></a>6.4.8　方法调用和返回指令</h2><p>&emsp;&emsp;方法调用（分派、执行过程）将在第8章具体讲解，这里仅列举以下5条用于方法调用的指令。</p>
<ul>
<li><strong>invokevirtual</strong>指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），这也是Java语言中最常见的方法分派方式。</li>
<li><strong>invokeinterface</strong>指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li>
<li><strong>invokespecial</strong>指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li>
<li><strong>invokestatic</strong>指令用于调用类方法（static方法）。</li>
<li><strong>invokedynamic</strong>指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
</ul>
<p>&emsp;&emsp;方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的，包括ireturn（当返回值是boolean、byte、char、short和int类型时使用）、lreturn、freturn、dreturn和areturn，另外还有一条return指令供声明为void的方法、实例初始化方法以及类和接口的类初始化方法使用。</p>
<h2 id="6-4-9-异常处理指令"><a href="#6-4-9-异常处理指令" class="headerlink" title="6.4.9　异常处理指令"></a>6.4.9　异常处理指令</h2><p>&emsp;&emsp;在Java程序中显式抛出异常的操作（throw语句）都由athrow指令来实现，除了用throw语句显式抛出异常情况之外，Java虚拟机规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出。例如，在前面介绍的整数运算中，当除数为零时，虚拟机会在idiv或ldiv指令中抛出ArithmeticException异常。</p>
<p>&emsp;&emsp;而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和ret指令来实现，现在已经不用了），而是采用异常表来完成的。</p>
<h2 id="6-4-10-同步指令"><a href="#6-4-10-同步指令" class="headerlink" title="6.4.10　同步指令"></a>6.4.10　同步指令</h2><p>&emsp;&emsp;Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。</p>
<p>&emsp;&emsp;方法级的同步是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池的方法表结构中的ACC_SYNCHRONIZED访问标志得知一个方法是否声明为同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那么这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。</p>
<p>&emsp;&emsp;同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持，譬如代码清单6-6中所示的代码。</p>
<p>&emsp;&emsp;代码清单6-6　代码同步演示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void onlyMe（Foo f）&#123;</div><div class="line">   synchronized（f）&#123;</div><div class="line">      doSomething()；</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;编译后，这段代码生成的字节码序列如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Method void onlyMe（Foo）</div><div class="line">0 aload_1//将对象f入栈</div><div class="line">1 dup//复制栈顶元素（即f的引用）</div><div class="line">2 astore_2//将栈顶元素存储到局部变量表Slot 2中</div><div class="line">3 monitorenter//以栈顶元素（即f）作为锁，开始同步</div><div class="line">4 aload_0//将局部变量Slot 0（即this指针）的元素入栈</div><div class="line">5 invokevirtual#5//调用doSomething()方法</div><div class="line">8 aload_2//将局部变量Slow 2的元素（即f）入栈</div><div class="line">9 monitorexit//退出同步</div><div class="line">10 goto 18//方法正常结束，跳转到18返回</div><div class="line">13 astore_3//从这步开始是异常路径，见下面异常表的Taget 13</div><div class="line">14 aload_2//将局部变量Slow 2的元素（即f）入栈</div><div class="line">15 monitorexit//退出同步</div><div class="line">16 aload_3//将局部变量Slow 3的元素（即异常对象）入栈</div><div class="line">17 athrow//把异常对象重新抛出给onlyMe()方法的调用者</div><div class="line">18 return//方法正常返回</div><div class="line">Exception table:</div><div class="line">FromTo Target Type</div><div class="line">4 10 13 any</div><div class="line">13 16 13 any</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法是正常结束还是异常结束。</p>
<p>&emsp;&emsp;从代码清单6-6的字节码序列中可以看到，为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</p>
<h1 id="6-5-公有设计和私有实现"><a href="#6-5-公有设计和私有实现" class="headerlink" title="6.5　公有设计和私有实现"></a>6.5　公有设计和私有实现</h1><p>&emsp;&emsp;Java虚拟机规范描绘了Java虚拟机应有的共同程序存储格式：Class文件格式以及字节码指令集。这些内容与硬件、操作系统及具体的Java虚拟机实现之间是完全独立的，虚拟机实现者可能更愿意把它们看做是程序在各种Java平台实现之间互相安全地交互的手段。</p>
<p>&emsp;&emsp;理解公有设计与私有实现之间的分界线是非常有必要的，Java虚拟机实现必须能够读取Class文件并精确实现包含在其中的Java虚拟机代码的语义。拿着Java虚拟机规范一成不变地逐字实现其中要求的内容当然是一种可行的途径，但一个优秀的虚拟机实现，在满足虚拟机规范的约束下对具体实现做出修改和优化也是完全可行的，并且虚拟机规范中明确鼓励实现者这样做。只要优化后Class文件依然可以被正确读取，并且包含在其中的语义能得到完整的保持，那实现者就可以选择任何方式去实现这些语义，虚拟机后台如何处理Class文件完全是实现者自己的事情，只要它在外部接口上看起来与规范描述的一致即可[1]。</p>
<p>&emsp;&emsp;虚拟机实现者可以使用这种伸缩性来让Java虚拟机获得更高的性能、更低的内存消耗或者更好的可移植性，选择哪种特性取决于Java虚拟机实现的目标和关注点是什么。虚拟机实现的方式主要有以下两种：</p>
<ul>
<li>将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集。</li>
<li>将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（即JIT代码生成技术）。</li>
</ul>
<p>&emsp;&emsp;精确定义的虚拟机和目标文件格式不应当对虚拟机实现者的创造性产生太多的限制，Java虚拟机应被设计成可以允许有众多不同的实现，并且各种实现可以在保持兼容性的同时提供不同的、新的、有趣的解决方案。</p>
<h1 id="6-6-Class文件结构的发展"><a href="#6-6-Class文件结构的发展" class="headerlink" title="6.6　Class文件结构的发展"></a>6.6　Class文件结构的发展</h1><p>&emsp;&emsp;Class文件结构自Java虚拟机规范第1版订立以来，已经有十多年的历史。这十多年间，Java技术体系有了翻天覆地的改变，JDK的版本号已经从1.0提升到了1.7。相对于语言、API以及Java技术体系中其他方面的变化，Class文件结构一直处于比较稳定的状态，Class文件的主体结构、字节码指令的语义和数量几乎没有出现过变动[1]，所有对Class文件格式的改进，都集中在向访问标志、属性表这些在设计上就可扩展的数据结构中添加内容。</p>
<p>&emsp;&emsp;如果以《Java虚拟机规范（第2版）》为基准进行比较的话，那么在后续Class文件格式的发展过程中，访问标志里新加入了ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM、ACC_BRIDGE、ACC_VARARGS共5个标志。而属性表集合中，在JDK 1.5到JDK 1.7版本之间一共增加了12项新的属性，这些属性大部分用于支持Java中许多新出现的语言特性，如枚举、变长参数、泛型、动态注解等。还有一些是为了支持性能改进和调试信息，譬如JDK 1.6的新类型校验器的StackMapTable属性和对非Java代码调试中用到的SourceDebugExtension属性。</p>
<p>&emsp;&emsp;Class文件格式所具备的平台中立（不依赖于特定硬件及操作系统）、紧凑、稳定和可扩展的特点，是Java技术体系实现平台无关、语言无关两项特性的重要支柱。</p>
<h1 id="6-7-本章小结"><a href="#6-7-本章小结" class="headerlink" title="6.7　本章小结"></a>6.7　本章小结</h1><p>&emsp;&emsp;Class文件是Java虚拟机执行引擎的数据入口，也是Java技术体系的基础构成之一。了解Class文件的结构对后面进一步了解虚拟机执行引擎有很重要的意义。</p>
<p>&emsp;&emsp;本章详细讲解了Class文件结构中的各个组成部分，以及每个部分的定义、数据结构和使用方法。通过代码清单6-1的Java代码与它的Class文件样例，以实战的方式演示了Class的数据是如何存储和访问的。从第7章开始，我们将以动态的、运行时的角度去看看字节码流在虚拟机执行引擎中是怎样被解释执行的。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/06/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/06/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-04-06T11:04:51+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="John Doe" />
          <p class="site-author-name" itemprop="name">John Doe</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
